<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>simple blog</title>
  
  <subtitle>try your best</subtitle>
  <link href="https://hzy2003628.top/atom.xml" rel="self"/>
  
  <link href="https://hzy2003628.top/"/>
  <updated>2023-03-09T13:46:56.300Z</updated>
  <id>https://hzy2003628.top/</id>
  
  <author>
    <name>dwb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>system()函数</title>
    <link href="https://hzy2003628.top/2023/03/09/system()%E5%87%BD%E6%95%B0/"/>
    <id>https://hzy2003628.top/2023/03/09/system()%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-09T13:46:56.105Z</published>
    <updated>2023-03-09T13:46:56.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>包含在头文件 “stdlib.h” 中</p><blockquote><p>int system(const char *command)</p></blockquote><h3 id="函数描述"><a href="#函数描述" class="headerlink" title="函数描述"></a>函数描述</h3><p>C 库函数 int system(const char *command) 把 command 指定的命令名称或程序名称传给要被命令处理器执行的主机环境，并在命令完成后返回。</p><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>命令执行成功返回0，执行失败返回-1。</p><h3 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h3><p>执行 dos(windows系统) 或 shell(Linux/Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。</p><ul><li>说明：在windows系统中，system函数直接在控制台调用一个command命令。<br>在Linux/Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程。<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4>一些system()函数的参数及实现的功能<br>表格里的内容可以通过 system(“HELP”);语句获取。<br><img src="https://img-blog.csdnimg.cn/bb68d0846b85442cb565ba9866ea98b1.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c9ef07eda9664e4fa31f997d77546789.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6672722285434a9d8d1361ca68586bc6.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a9d38b782c864c97ab08f2ae8a0414b0.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4bc331b6ef8b4746bb59cdb8b2196847.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/274611ecbe3841e3a30b1f4e4e2714a0.png#pic_center" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/1ced2ae69d624ac09ffd0f25f40a4f17.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;函数原型&quot;&gt;&lt;a href=&quot;#函数原型&quot; class=&quot;headerlink&quot; title=&quot;函数原型&quot;&gt;&lt;/a&gt;函数原型&lt;/h3&gt;&lt;p&gt;包含在头文件 “stdlib.h” 中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;int system(const char </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sha1算法</title>
    <link href="https://hzy2003628.top/2023/03/09/sha1%E7%AE%97%E6%B3%95/"/>
    <id>https://hzy2003628.top/2023/03/09/sha1%E7%AE%97%E6%B3%95/</id>
    <published>2023-03-09T12:33:14.830Z</published>
    <updated>2023-03-09T12:33:15.033Z</updated>
    
    <content type="html"><![CDATA[<p>sha1算法又名<strong>哈希算法</strong></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>SHA-1（Secure Hash Algorithm 1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦资料处理标准（FIPS）。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><h5 id="消息填充-Message-Padding"><a href="#消息填充-Message-Padding" class="headerlink" title="消息填充(Message Padding)"></a>消息填充(Message Padding)</h5><h5 id="步骤一-数据填充-Append-Padding-Bits"><a href="#步骤一-数据填充-Append-Padding-Bits" class="headerlink" title="步骤一: 数据填充(Append Padding Bits)"></a>步骤一: 数据填充(Append Padding Bits)</h5><p>SHA-1是按照分块进行处理的，分块长度为512bit, 大多数情况下，数据的长度不会恰好满足是512的整数倍，因此需要进行「padding」到给定的长度。<br><strong>「填充规则」:</strong> 原始明文消息的b位之后补100…, 直到满足b + paddingLength % 512 = 448, 那如果b % 512在[448, 512(0)]之间呢，则在增加一个分块，按照前面的规则填充即可。</p><h5 id="长度填充"><a href="#长度填充" class="headerlink" title="长度填充"></a>长度填充</h5><p>之前说了，需要满足b + paddingLength % 512 = 448， 那么对于最后一个分块，就还剩512 - 448 = 64 bit 这剩下的64bit存放的是原始消息的长度，也就是b。「SHA-1」最多可以处理明文长度小于等于2^64 bit的数据。<br><img src="https://img-blog.csdnimg.cn/10238576ec144c1b9fbb24a138939a86.png#pic_center" alt="在这里插入图片描述"></p><h6 id="计算摘要-Computing-the-Message-Digest"><a href="#计算摘要-Computing-the-Message-Digest" class="headerlink" title="计算摘要(Computing the Message Digest)"></a>计算摘要(Computing the Message Digest)</h6><p><img src="https://img-blog.csdnimg.cn/a78d64fa7a0a4d08895c189a4af6a9bf.png" alt="在这里插入图片描述"><br>首先, 初始化5个常量, 如下所示, 类比于「MD5」可以看做是「MDBuffer」:</p><blockquote><p>H0 = 0x67452301<br>H1 = 0xEFCDAB89<br>H2 = 0x98BADCFE<br>H3 = 0x10325476<br>H4 = 0xC3D2E1F0</p></blockquote><p>然后对于消息按照如下的方式进行处理:</p><ul><li>前16个字节([0, 15])，转换成32位无符号整数。</li><li>对于后面的字节([16, 79])按照下面的公式进行处理</li></ul><blockquote><p>W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16))</p></blockquote><ul><li>令A = H0, B = H1, C = H2, D = H3, E = H4</li><li>做如下80轮的散列操作</li></ul><blockquote><p>TEMP = S^5(A) + f(t;B,C,D) + E + W(t) + K(t);<br>E = D;<br>D = C;<br>C = S^30(B);<br>B = A;<br>A = TEMP;</p></blockquote><ul><li>令H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E<br>解释一下，其中f函数如下:</li></ul><blockquote><p>f(t;B,C,D) = (B AND C) OR ((NOT B) AND D)         ( 0 &lt;= t &lt;= 19)<br>f(t;B,C,D) = B XOR C XOR D                        (20 &lt;= t &lt;= 39)<br>f(t;B,C,D) = (B AND C) OR (B AND D) OR (C AND D)  (40 &lt;= t &lt;= 59)<br>f(t;B,C,D) = B XOR C XOR D                        (60 &lt;= t &lt;= 79)</p></blockquote><p>k函数如下：</p><blockquote><p>K(t) = 0x5A827999         ( 0 &lt;= t &lt;= 19)<br>K(t) = 0x6ED9EBA1         (20 &lt;= t &lt;= 39)<br>K(t) = 0x8F1BBCDC         (40 &lt;= t &lt;= 59)<br>K(t) = 0xCA62C1D6         (60 &lt;= t &lt;= 79)</p></blockquote><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><p>最后H0~H4即为最终「SHA-1」的输出结果。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs html">pub struct SHA1 &#123;&#125;impl SHA1 &#123;    fn padding(message: &amp;[u8]) -&gt; Vec<span class="hljs-tag">&lt;<span class="hljs-name">u8</span>&gt;</span> &#123;        let mut result = message.to_owned();        // padding 1        result.push(0x80);        // padding 0        while ((result.len() * 8) + 64) % 512 != 0 &#123;            result.push(0b00000000);        &#125;        // padding message length 注意这里和MD5不同，没仔细看踩了一个大坑 这里长度padding到前面        for byte in &amp;((message.len() * 8) as u64).to_be_bytes() &#123;            result.push(*byte);        &#125;        return result;    &#125;    fn k(t: usize) -&gt; u32 &#123;        match t &#123;            n if n &lt; 20 =&gt; 0x5A827999,            n if 20 &lt;= n &amp;&amp; n &lt; 40 =&gt; 0x6ED9EBA1,            n if 40 &lt;= n &amp;&amp; n &lt; 60 =&gt; 0x8F1BBCDC,            n if 60 &lt;= n &amp;&amp; n &lt; 80 =&gt; 0xCA62C1D6,            _ =&gt; 0,        &#125;    &#125;    fn f(t: usize, b: u32, c: u32, d: u32) -&gt; u32 &#123;        match t &#123;            n if n &lt; 20 =&gt; (b &amp; c) | ((!b) &amp; d),            n if 20 &lt;= n &amp;&amp; n &lt; 40 =&gt; b ^ c ^ d,            n if 40 &lt;= n &amp;&amp; n &lt; 60 =&gt; (b &amp; c) | (b &amp; d) | (c &amp; d),            n if 60 &lt;= n &amp;&amp; n &lt; 80 =&gt; b ^ c ^ d,            _ =&gt; 0,        &#125;    &#125;    pub fn hash(message: &amp;[u8]) -&gt; String &#123;        let padding_message = SHA1::padding(message);        let mut buf: [u32; 5]; // Buffer one, A..E        let mut h: [u32; 5] = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];        let mut w = [0u32; 80]; // Sequance of W(0)..W(79)        let mut temp: u32;        for chunk in padding_message.chunks(64) &#123;            // 注意这里用的是big-edition            let m: Vec<span class="hljs-tag">&lt;<span class="hljs-name">u32</span>&gt;</span> = chunk.chunks(4).map(|i| &#123;                ((i[0] as u32) &lt;&lt; 24) | ((i[1] as u32) &lt;&lt; 16) | ((i[2] as u32) &lt;&lt; 8) | ((i[3] as u32) &lt;&lt; 0)            &#125;).collect();            for i in 0..16 &#123;                w[i] = m[i];            &#125;            for t in 16..80 &#123;                // W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16)).                w[t] = (w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]).rotate_left(1);            &#125;            buf = h;            for t in 0..80 &#123;                // TEMP = S^5(A) + f(t;B,C,D) + E + W(t) + K(t);                temp = buf[0].rotate_left(5).wrapping_add(                    SHA1::f(t, buf[1], buf[2], buf[3])                        .wrapping_add(buf[4].wrapping_add(w[t].wrapping_add(SHA1::k(t)))),                );                buf[4] = buf[3]; // E = D                buf[3] = buf[2]; // D = C                buf[2] = buf[1].rotate_left(30); // C = S^30(B)                buf[1] = buf[0]; // B = A                buf[0] = temp; // A = TEMP            &#125;            for i in 0..5 &#123;                h[i] = h[i].wrapping_add(buf[i]);            &#125;        &#125;        // output        return String::from(format!(            &quot;&#123;:08x&#125;&#123;:08x&#125;&#123;:08x&#125;&#123;:08x&#125;&#123;:08x&#125;&quot;,            h[0], h[1], h[2], h[3], h[4]        ));    &#125;&#125;#[cfg(test)]mod test &#123;    use crate::sha1::SHA1;    #[test]    fn test() &#123;        println!(&quot;sha1([empty string]) = &#123;&#125;&quot;, SHA1::hash(&quot;&quot;.as_bytes()));        println!(&quot;sha1([The quick brown fox jumps over the lazy dog]) = &#123;&#125;&quot;, SHA1::hash(&quot;The quick brown fox jumps over the lazy dog&quot;.as_bytes()));    &#125;&#125;</code></pre><h6 id="在线SHA-1加密工具"><a href="#在线SHA-1加密工具" class="headerlink" title="在线SHA-1加密工具"></a>在线SHA-1加密工具</h6><p><a href="https://uutool.cn/sha1/">https://uutool.cn/sha1/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;sha1算法又名&lt;strong&gt;哈希算法&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;SHA-1（Secure Hash Algorithm 1）是一种</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>刷题记录reverse2</title>
    <link href="https://hzy2003628.top/2023/03/03/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95reverse2/"/>
    <id>https://hzy2003628.top/2023/03/03/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95reverse2/</id>
    <published>2023-03-03T13:18:09.133Z</published>
    <updated>2023-03-03T13:18:09.372Z</updated>
    
    <content type="html"><![CDATA[<p>攻防世界<br>reverse</p><h1 id="srm-50"><a href="#srm-50" class="headerlink" title="srm-50"></a>srm-50</h1><p>拖入EXE，无壳，拖入32位IDA<br>WINMAIN(xxx)函数F5反汇编<br>双击跟进DialogFunc<br>strcpy(Source, “Registration Success!\nYour flag is:”)后的内容就是flag，快捷键R将数字转换成字符串<br><img src="https://img-blog.csdnimg.cn/55c04856878949e6b9e1eee095d07016.png#pic_center" alt="在这里插入图片描述"><br>即CXZA9bd7mGq94gc8<br>按顺序排列后得到CZ9dmq4c8g9G7bAX，即为flag</p><h1 id="Mysterious"><a href="#Mysterious" class="headerlink" title="Mysterious"></a>Mysterious</h1><p>拖入exe，无壳，拖入32位IDA<br>找到WinMain(x,x,x,x)  F5反汇编<br>双击跟进_WinMain@16_0，跟进DialogFunc，进入sub_401090<br>找到well done 所在的基本块，条件是v10 == 123 &amp;&amp; v12 == 120 &amp;&amp; v14 == 122 &amp;&amp; v13 == 121，注意到在该基本块的开头调用了strcpy函数将flag 赋值给Text，同时下面也有一些对Text拼接字符串的操作，看起来这个Text保存的就是flag。<br>观察Text的赋值，除了v5，其它的都是已知的字符，需要解出v5的值。其中，v5是执行itoa函数以后得到的：_itoa(v10, &amp;v5, 10); 。<br>因此，我们需要把v10解出来。v10等于多少呢？if条件里已经告诉我们了，等于123，因此flag为flag{123_Buff3r_0v3rf|0w}<br><strong>补充：</strong><br>此题想考察的应该是溢出<br>第25行中，读取用户输入保存到String，读取的最大长度为260字节，并且没有对String做长度校验，可能存在溢出的问题。</p><blockquote><p>GetDlgItemTextA(hWnd, 1002, &amp;String, 260);</p></blockquote><p>然后对String进行了长度校验，必须要大于6才行。<br>接下来 v10 = atoi(&amp;String) + 1; ，也就是用户输入是个数字的字符串，通过atoi转成数字以后再加一，将结果赋值给v10。因此输入的前三个字符应该为：”123”。<br>重头戏来了，还是这个if条件，对v10，v12，v13和v14进行了判断。</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( v10 == <span class="hljs-number">123</span> &amp;&amp; v12 == <span class="hljs-number">120</span> &amp;&amp; v14 == <span class="hljs-number">122</span> &amp;&amp; v13 == <span class="hljs-number">121</span> )&#123;    ...&#125;</code></pre><p>string~v14在栈中的情况<br><img src="https://img-blog.csdnimg.cn/f4c2d06b1d6949328eba8a410ae996a9.png" alt="在这里插入图片描述"><br>String这三个字节填充的是122无疑，v12、v13、v14的ASCII值分别为120、121、122，即对应的字符为x、y、z<br><img src="https://img-blog.csdnimg.cn/5ca97d34114143919b1230b993408100.png#pic_center" alt="在这里插入图片描述"><br>用户输入为122xyz<br>输出为flag{123_Buff3r_0v3rfl0w}<br><img src="https://img-blog.csdnimg.cn/6a9f6008dc394205a5b879af3a58fc87.png#pic_center" alt="在这里插入图片描述"></p><h1 id="Guess-the-Number"><a href="#Guess-the-Number" class="headerlink" title="Guess-the-Number"></a>Guess-the-Number</h1><p>附件加载后得到.jar解压后得到.class文件<br>学习发现需要一个叫jd-gui的软件打开<br>下载后用其打开可以查看汇编代码<br><img src="https://img-blog.csdnimg.cn/ee287082b49742219425dd9a98a7b694.png#pic_center" alt="在这里插入图片描述"><br>分析if (my_number / 5 == guess_number)  //我的数字除以5取整就是猜测的数字<br>1545686892 / 5取整得309137378<br>将guess_number的值修改为309137378，执行代码成功获得flag为a7b08c546302cc1fd2a4d48bf2bf2ddb。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;攻防世界&lt;br&gt;reverse&lt;/p&gt;
&lt;h1 id=&quot;srm-50&quot;&gt;&lt;a href=&quot;#srm-50&quot; class=&quot;headerlink&quot; title=&quot;srm-50&quot;&gt;&lt;/a&gt;srm-50&lt;/h1&gt;&lt;p&gt;拖入EXE，无壳，拖入32位IDA&lt;br&gt;WINMAIN(xx</summary>
      
    
    
    
    <category term="刷题" scheme="https://hzy2003628.top/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>itoa函数</title>
    <link href="https://hzy2003628.top/2023/02/28/itoa%E5%87%BD%E6%95%B0/"/>
    <id>https://hzy2003628.top/2023/02/28/itoa%E5%87%BD%E6%95%B0/</id>
    <published>2023-02-28T12:15:41.953Z</published>
    <updated>2023-02-28T12:15:42.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>itoa 为c语言的一个函数。itoa 函数是一个广泛应用的，从非标准扩展到标准的C语言。它不能被移植，因为它不是标准定义下的C语言，但是，编译器通常在一个不遵循程式标准的模式下允许其通过header ，因为它是一个从逻辑对应到标准库的函数。itoa 取整数输入值，并将其转换为相应进制数字的字符串。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>把一个整数转换为字符串</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>itoa(i ,num ,10 );<br>i —- 需要转换成字符串的数字<br>num —- 转换后保存字符串的变量<br>10 —- 转换数字的基数（即进制）。10就是说按10进制转换数字。还可以是2，8，16等等你喜欢的进制类型<br>返回值：指向num这个字符串的指针</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>itoa() 函数有3个参数：第一个参数是要转换的数字，第二个参数是要写入转换结果的目标字符串，第三个参数是转移数字时所用的基数(进制)。在上例中，转换基数为10，就意味着以10为转换进制。10：十进制；2：二进制…<br>itoa 并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用sprintf。<br>标准库中有sprintf，功能比这个更强，用法跟printf类似：<br>char str[255];<br>sprintf(str, “%x”, 100); //将100转为16进制表示的字符串。<br>下列函数也可以将相应类型的整数转换为字符串：</p><h2 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h2><p>char *ultoa(unsigned long value,char *string,int radix)<br>将无符号整型数value转换成字符串并返回该字符串,radix为转换时所用基数<br>char *ltoa(long value,char *string,int radix)<br>将长整型数value转换成字符串并返回该字符串,radix为转换时所用基数<br>char *itoa(int value,char *string,int radix)<br>将整数value转换成字串存入string,radix为转换所用基数.<br>double atof(char *nptr)<br>将字符串nptr转换成双精度数,并返回这个数,错误返回0<br>int atoi(char *nptr)<br>将字符串nptr转换成整型数, 并返回这个数,错误返回0<br>long atol(char *nptr)<br>将字符串nptr转换成长整型数,并返回这个数,错误返回0<br>double strtod(char *str,char **endptr)<br>将字符串str转换成双精度数,并返回这个数,<br>long strtol(char *str,char **endptr,int base)<br>将字符串str转换成长整型数, 并返回这个数,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;itoa 为c语言的一个函数。itoa 函数是一个广泛应用的，从非标准扩展到标准的C语言。它不能被移植，因为它不是标准定义下的C语言，但是，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>幂数加密</title>
    <link href="https://hzy2003628.top/2023/02/27/%E5%B9%82%E6%95%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://hzy2003628.top/2023/02/27/%E5%B9%82%E6%95%B0%E5%8A%A0%E5%AF%86/</id>
    <published>2023-02-27T13:27:09.562Z</published>
    <updated>2023-02-27T13:27:50.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制幂数加密法"><a href="#二进制幂数加密法" class="headerlink" title="二进制幂数加密法"></a>二进制幂数加密法</h2><h6 id="何为幂数加密"><a href="#何为幂数加密" class="headerlink" title="何为幂数加密"></a>何为幂数加密</h6><p>二进制幂数加密通过二进制的几次方表示字母的序号来对信息加密。由二进制转换成十进制的时候，还可以表示成2的N次方的形式。由于英文字母只有26个字母。只要2的0、1、2、3、4、5次幂就可以表示31个单元。通过用二进制幂数表示字母序号数来加密。<br>例如<br>明文： d o n o t p u l l a l l y o u r e g g s i n o n e b a s k e t<br>字母序号：4 15 14 15 20 16 21 12 12 1 12 12 25 15 21 18 5 7 7 19 9 14 15 14 5 2 1 19 11 5 20<br>由于4=2^2 所以D加密过之后是2；15=2^0+2^1+2^2+2^3所以O加密后是0123。同理得到上述明文的加密后的密文<br>密文：2 0123/123 0123 24/4 024 23 23/0 23 23/034 0123 024 14/02 012 012 014/03 123 /0123 123 02/1 0 014 013 02 24<br>空格表示字母的间隔，“/”表示单词的间隔</p><h4 id="二进制幂数加密转换表"><a href="#二进制幂数加密转换表" class="headerlink" title="二进制幂数加密转换表"></a>二进制幂数加密转换表</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>A 1——0</td><td>N 14——123</td></tr><tr><td>B 2——1</td><td>O 15——0123</td></tr><tr><td>C 3——01</td><td>P 16——4</td></tr><tr><td>D 4——2</td><td>Q 17——04</td></tr><tr><td>E 5——02</td><td>R 18——14</td></tr><tr><td>F 6——12</td><td>S 19—–014</td></tr><tr><td>G 7——012</td><td>T 20—–24</td></tr><tr><td>H 8——3</td><td>U 21—–024</td></tr><tr><td>I 9——03</td><td>V 22—–124</td></tr><tr><td>J 10—–13</td><td>W 23—–0124</td></tr><tr><td>K 11—–013</td><td>X 24——34</td></tr><tr><td>L 12—–23</td><td>Y 25—–034</td></tr><tr><td>M 13—-023</td><td>Z 26—–134</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二进制幂数加密法&quot;&gt;&lt;a href=&quot;#二进制幂数加密法&quot; class=&quot;headerlink&quot; title=&quot;二进制幂数加密法&quot;&gt;&lt;/a&gt;二进制幂数加密法&lt;/h2&gt;&lt;h6 id=&quot;何为幂数加密&quot;&gt;&lt;a href=&quot;#何为幂数加密&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>栅栏密码&amp;W型栅栏密码</title>
    <link href="https://hzy2003628.top/2023/02/27/%E6%A0%85%E6%A0%8F%E5%AF%86%E7%A0%81/"/>
    <id>https://hzy2003628.top/2023/02/27/%E6%A0%85%E6%A0%8F%E5%AF%86%E7%A0%81/</id>
    <published>2023-02-27T12:50:02.017Z</published>
    <updated>2023-02-27T13:28:20.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话）</p><h3 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h3><p>①把将要传递的信息中的字母交替排成上下两行。<br>②再将下面一行字母排在上面一行的后边，从而形成一段密码。<br>③例如：<br>明文：THE LONGEST DAY MUST HAVE AN END<br>加密：<br>1、把将要传递的信息中的字母交替排成上下两行。<br>T E O G S D Y U T A E N N<br>H L N E T A M S H V A E D<br>2、 密文：<br>将下面一行字母排在上面一行的后边。<br>TEOGSDYUTAENN HLNETAMSHVAED<br>解密：<br>先将密文分为两行<br>T E O G S D Y U T A E N N<br>H L N E T A M S H V A E D<br>再按上下上下的顺序组合成一句话<br>明文：THE LONGEST DAY MUST HAVE AN END</p><h3 id="解密代码"><a href="#解密代码" class="headerlink" title="解密代码"></a>解密代码</h3><p>传统栅栏密码的密钥是密文长度的因数。<br>如密文长度为n，加密密钥为x，则有n%x==0。且解密密钥即为n/x。<br>代码：</p><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">遍历所有可能的栏数，并得到加/解密结果</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>s = <span class="hljs-string">&#x27;KYsd3js2E&#123;a2jda&#125;&#x27;</span>factors = [fac <span class="hljs-keyword">for</span> fac <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(s)) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s)%fac == <span class="hljs-number">0</span>] <span class="hljs-comment">#取得密文长度的所有因数</span><span class="hljs-keyword">for</span> fac <span class="hljs-keyword">in</span> factors:    flag = <span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(fac): <span class="hljs-comment">#按一定的步长取几组字符，并连接起来，这里组数就等于步长数</span>        flag += s[i::fac]    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(fac)+<span class="hljs-string">&#x27;栏：&#x27;</span>+flag)</code></pre><h2 id="W型栅栏密码"><a href="#W型栅栏密码" class="headerlink" title="W型栅栏密码"></a>W型栅栏密码</h2><p>W型栅栏密码是栅栏密码的变种，<br>将明文按w型排列，然后将每一行的字母依次连起来组成密文，行数就是密钥。<br>解密则同样画出这个w型图案，将每一列的字母依次连接起来组成明文。<br>W型栅栏密码的密钥不只是密文长度的因数，任何小于密文长度大于1的整数都有可能。<br>代码：</p><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">若知道栏数，则使用decode解密，若不知道，则使用crack_cipher遍历所有可能性</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_w</span>(<span class="hljs-params">string, n</span>):     <span class="hljs-string">&#x27;&#x27;&#x27;将字符排列成w型&#x27;&#x27;&#x27;</span>    array = [[<span class="hljs-string">&#x27;.&#x27;</span>]*<span class="hljs-built_in">len</span>(string) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-comment">#生成初始矩阵</span>    row = <span class="hljs-number">0</span>    upflag = <span class="hljs-literal">False</span>    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(string)): <span class="hljs-comment">#在矩阵上按w型画出string</span>        array[row][col] = string[col]        <span class="hljs-keyword">if</span> row == n-<span class="hljs-number">1</span>:            upflag = <span class="hljs-literal">True</span>        <span class="hljs-keyword">if</span> row == <span class="hljs-number">0</span>:            upflag = <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> upflag:            row -= <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            row += <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> array<span class="hljs-keyword">def</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params">string, n</span>):    <span class="hljs-string">&#x27;&#x27;&#x27;加密&#x27;&#x27;&#x27;</span>    array = generate_w(string, n)    msg = []    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): <span class="hljs-comment">#将每行的字符连起来</span>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(string)):            <span class="hljs-keyword">if</span> array[row][col] != <span class="hljs-string">&#x27;.&#x27;</span>:                msg.append(array[row][col])    <span class="hljs-keyword">return</span> array, msg<span class="hljs-keyword">def</span> <span class="hljs-title function_">decode</span>(<span class="hljs-params">string, n</span>):    <span class="hljs-string">&#x27;&#x27;&#x27;解密&#x27;&#x27;&#x27;</span>    array = generate_w(string, n)    sub = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): <span class="hljs-comment">#将w型字符按行的顺序依次替换为string</span>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(string)):            <span class="hljs-keyword">if</span> array[row][col] != <span class="hljs-string">&#x27;.&#x27;</span>:                array[row][col] = string[sub]                sub += <span class="hljs-number">1</span>    msg = []    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(string)): <span class="hljs-comment">#以列的顺序依次连接各字符</span>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            <span class="hljs-keyword">if</span> array[row][col] != <span class="hljs-string">&#x27;.&#x27;</span>:                msg.append(array[row][col])    <span class="hljs-keyword">return</span> array, msg<span class="hljs-keyword">def</span> <span class="hljs-title function_">crack_cipher</span>(<span class="hljs-params">string</span>):    <span class="hljs-string">&#x27;&#x27;&#x27;破解密码&#x27;&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(string)): <span class="hljs-comment">#遍历所有可能的栏数</span>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(n)+<span class="hljs-string">&#x27;栏：&#x27;</span>+<span class="hljs-string">&#x27;&#x27;</span>.join(decode(string, n)[<span class="hljs-number">1</span>]))<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    string = <span class="hljs-string">&quot;ccehgyaefnpeoobe&#123;lcirg&#125;epriec_ora_g&quot;</span>    n = <span class="hljs-number">5</span> <span class="hljs-comment">#栏数</span>    <span class="hljs-comment">#若不知道栏数，则遍历所有可能</span>    <span class="hljs-comment"># crack_cipher(string)</span>    <span class="hljs-comment">#若知道栏数</span>    array,msg = decode(string, n)    <span class="hljs-comment"># array,msg = encode(string, n)</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array: <span class="hljs-built_in">print</span>(i)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(msg))</code></pre><h6 id="WWW型的解密网站"><a href="#WWW型的解密网站" class="headerlink" title="WWW型的解密网站"></a>WWW型的解密网站</h6><p><a href="http://www.atoolbox.net/Tool.php?Id=777">http://www.atoolbox.net/Tool.php?Id=777</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栅栏密码&quot;&gt;&lt;a href=&quot;#栅栏密码&quot; class=&quot;headerlink&quot; title=&quot;栅栏密码&quot;&gt;&lt;/a&gt;栅栏密码&lt;/h1&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>刷题记录reverse</title>
    <link href="https://hzy2003628.top/2023/02/27/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95reverse/"/>
    <id>https://hzy2003628.top/2023/02/27/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95reverse/</id>
    <published>2023-02-27T12:32:53.956Z</published>
    <updated>2023-02-27T13:28:00.799Z</updated>
    
    <content type="html"><![CDATA[<p>攻防世界<br>reverse</p><h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h2><p>拖入exe<br><img src="https://img-blog.csdnimg.cn/33a7b6b7487d440aaae31200446f117e.png#pic_center" alt="在这里插入图片描述"></p><p>发现无壳并拖入64位IDA<br>F5反汇编<br>‘R’键将数字转换成字符串<br><img src="https://img-blog.csdnimg.cn/1dfd3cf2f3044f71a61f43e9385f9c3d.png" alt="在这里插入图片描述"><br>可以知道控制方向键的分别为“O”，“o”，“.”，“0”<br>判断分别代表什么方向：<br><img src="https://img-blog.csdnimg.cn/0c3a343474674e78bb7c6e2162975f43.png#pic_center" alt="在这里插入图片描述"><br>左减右加，上减下加<br>O左移 o右移 .上移 0下移<br>判断迷宫的x轴和y轴<br><img src="https://img-blog.csdnimg.cn/9ee7e111dce7434b8b93d7f9665e8286.png#pic_center" alt="在这里插入图片描述"><br>所以迷宫的起点就是（0，0）</p><p>sub_400690函数中是a2+a3*8,即a3表示行，a2表示列<br>a3 通过edx传递<br>a2 通过esi传递<br>行×8？再去看这个字符串，发现是64位，正好就是8×8<br>双击asc_601060查看字符串<br>用记事本整理得迷宫图形</p><pre><code class="hljs bash">  *******   *  **** * ****  * ***  *<span class="hljs-comment">#  *</span>** *** ***     *********</code></pre><p>*是边界，空格是通路，＃号是终点。<br>O是左移，o是右移，0是下移，.是上移<br>得到flag为nctf{o0oo00O000oooo..OO}</p><h2 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h2><p>拖进exe，无壳，拖入32位IDA<br>F5反汇编<br><img src="https://img-blog.csdnimg.cn/4fd53107f60c45b5b54b7a7340406bbc.png#pic_center" alt="在这里插入图片描述"></p><p>没想到直接看到flag，SECCON{Welcome to the SECCON 2014 CTF!}，提交竟然是对的</p><h2 id="dmd-50"><a href="#dmd-50" class="headerlink" title="dmd-50"></a>dmd-50</h2><p>拖入EXE，无壳，拖入64位IDA，F5反汇编<br>R快捷键将ASCII码转成字符<br><img src="https://img-blog.csdnimg.cn/84115edbcb7040ed8b921e14b3e66484.png#pic_center" alt="在这里插入图片描述"><br>得到字符串870438d5b6e29db0898bc4f0225935c0<br>根据题目名称dmd-50猜测这是MD5密文，故将字符串解密得到grape<br>然而这并不是flag<br><img src="https://img-blog.csdnimg.cn/6b2ab4c1e129412aa7fc1c6370af99b9.png#pic_center" alt="在这里插入图片描述"><br>发现重点md5(v40,v39)<br>意思是md5加密一次<br>将刚得到的grape再次md5加密<br>得到flag为b781cbb29054db12f88f08c6e161c199</p><h2 id="lgniteMe"><a href="#lgniteMe" class="headerlink" title="lgniteMe"></a>lgniteMe</h2><p>拖入exe，无壳，拖入32位IDA，F5反汇编<br><img src="https://img-blog.csdnimg.cn/a1a4641e93b046b1a45c54a0f253787a.png#pic_center" alt="在这里插入图片描述"><br>发现”Congratulations!”，应该是输入正确flag后的输出，故双击跟进sub_4011c0<br><img src="https://img-blog.csdnimg.cn/18d8887124934a4181848565d7cc625b.png#pic_center" alt="在这里插入图片描述"><br>存在两个函数异或，进入函数byte_4420B0<br>选中后按shift+e提取字符，选择demical十进制的数表示<br><img src="https://img-blog.csdnimg.cn/7d29c82de70e4773aa12bf85e547507e.png#pic_center" alt="在这里插入图片描述"><br>编写脚本：</p><pre><code class="hljs python">yihuo_qian =(   <span class="hljs-number">13</span>,  <span class="hljs-number">19</span>,  <span class="hljs-number">23</span>,  <span class="hljs-number">17</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">1</span>,  <span class="hljs-number">32</span>,  <span class="hljs-number">29</span>,  <span class="hljs-number">12</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">25</span>,  <span class="hljs-number">47</span>,  <span class="hljs-number">23</span>,  <span class="hljs-number">43</span>,  <span class="hljs-number">36</span>,  <span class="hljs-number">31</span>,  <span class="hljs-number">30</span>,  <span class="hljs-number">22</span>,   <span class="hljs-number">9</span>,  <span class="hljs-number">15</span>,   <span class="hljs-number">21</span>,  <span class="hljs-number">39</span>,  <span class="hljs-number">19</span>,  <span class="hljs-number">38</span>,  <span class="hljs-number">10</span>,  <span class="hljs-number">47</span>,  <span class="hljs-number">30</span>,  <span class="hljs-number">26</span>,  <span class="hljs-number">45</span>,  <span class="hljs-number">12</span>,   <span class="hljs-number">34</span>)flag = <span class="hljs-string">&#x27;&#x27;</span>yihuo_result=<span class="hljs-string">&#x27;GONDPHyGjPEKruv&#123;&#123;pj]X@rF&#x27;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(yihuo_result)):    flag+=<span class="hljs-built_in">chr</span>(((<span class="hljs-built_in">ord</span>(yihuo_result[i])^yihuo_qian[i])-<span class="hljs-number">72</span>)^<span class="hljs-number">85</span>)<span class="hljs-built_in">print</span>(flag)</code></pre><p>得到flag为EIS{WADX_TDGK_AIHC_IHKN_PJLM}（不过不知道提交为什么就是不正确）<br>还发现一种大佬的一种解法<br>shift+F2在IDA中嵌入脚本打印<br>脚本为：</p><pre><code class="hljs bash">addr=0x4420B0list=[]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(32):        list.append(Byte(addr+i))<span class="hljs-built_in">print</span>(list)</code></pre><p>逆向逻辑脚本为：</p><pre><code class="hljs python">key1=<span class="hljs-string">&quot;GONDPHyGjPEKruv&#123;&#123;pj]X@rF&quot;</span>list1=[<span class="hljs-number">13</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">29</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-number">25</span>, <span class="hljs-number">47</span>, <span class="hljs-number">23</span>, <span class="hljs-number">43</span>, <span class="hljs-number">36</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">22</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>, <span class="hljs-number">39</span>, <span class="hljs-number">19</span>, <span class="hljs-number">38</span>, <span class="hljs-number">10</span>, <span class="hljs-number">47</span>, <span class="hljs-number">30</span>, <span class="hljs-number">26</span>, <span class="hljs-number">45</span>, <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">4</span>]flag=[]v3=<span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key1)):   flag.append(((<span class="hljs-built_in">ord</span>(key1[i])^list1[i])-<span class="hljs-number">72</span>)^<span class="hljs-number">85</span>)   <span class="hljs-keyword">if</span> flag[i] &gt;= <span class="hljs-number">65</span> <span class="hljs-keyword">and</span> flag[i] &lt;= <span class="hljs-number">90</span>:      flag[i]+=<span class="hljs-number">32</span>   <span class="hljs-keyword">elif</span> flag[i] &gt;= <span class="hljs-number">97</span> <span class="hljs-keyword">and</span> flag[i] &lt;=<span class="hljs-number">122</span>:      flag[i]-=<span class="hljs-number">32</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> flag]))<span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> flag])))</code></pre><h2 id="re-for-50-plz-50"><a href="#re-for-50-plz-50" class="headerlink" title="re-for-50-plz-50"></a>re-for-50-plz-50</h2><p>拖入EXE，无壳，拖入32位IDA。F5查看伪代码<br><img src="https://img-blog.csdnimg.cn/08b6d1321ee643c0b747187d12aafc95.png#pic_center" alt="在这里插入图片描述"><br>代码非常简单，很好理解<br>进入函数meow，得到字符串<br><img src="https://img-blog.csdnimg.cn/ad4d5d67296c4e21b26179375abebaaa.png#pic_center" alt="在这里插入图片描述"><br>编写脚本：</p><pre><code class="hljs python">a = <span class="hljs-string">&quot;cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ&quot;</span>f = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):    f += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(a[i])^<span class="hljs-number">55</span>)<span class="hljs-built_in">print</span>(f)</code></pre><p>运行得到flag为TUCTF{but_really_whoisjohngalt}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;攻防世界&lt;br&gt;reverse&lt;/p&gt;
&lt;h2 id=&quot;maze&quot;&gt;&lt;a href=&quot;#maze&quot; class=&quot;headerlink&quot; title=&quot;maze&quot;&gt;&lt;/a&gt;maze&lt;/h2&gt;&lt;p&gt;拖入exe&lt;br&gt;&lt;img src=&quot;https://img-blog.csd</summary>
      
    
    
    
    <category term="刷题" scheme="https://hzy2003628.top/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>IDA中的IDC脚本编写笔记</title>
    <link href="https://hzy2003628.top/2023/02/26/IDA%E4%B8%AD%E7%9A%84IDC%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E7%AC%94%E8%AE%B0/"/>
    <id>https://hzy2003628.top/2023/02/26/IDA%E4%B8%AD%E7%9A%84IDC%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E7%AC%94%E8%AE%B0/</id>
    <published>2023-02-26T08:33:43.888Z</published>
    <updated>2023-02-26T08:36:18.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IDC"><a href="#IDC" class="headerlink" title="IDC"></a>IDC</h2><p>首先，什么是IDC？<br>IDC是IDA中支持的一门与C语言类似的语言，但是它是解释型的，并不是编译型的，于此同时IDC还融合了一些python中的元素以方便一些内容的处理。</p><p>在IDA中按下【shift+F2】可调出脚本编译器</p><h4 id="IDC语句"><a href="#IDC语句" class="headerlink" title="IDC语句"></a>IDC语句</h4><p>IDC支持C中的语言，除了switch</p><h4 id="IDC表达式"><a href="#IDC表达式" class="headerlink" title="IDC表达式"></a>IDC表达式</h4><p>IDC几乎都能支持C语言中的操作运算表达（加减乘除、判等家族），但是明确说明不支持+=。<br>在进行操作运算的时候，只有操作中存在64bit的操作，那么其他操作也会编程64bit的。</p><h4 id="IDC预定义符号"><a href="#IDC预定义符号" class="headerlink" title="IDC预定义符号"></a>IDC预定义符号</h4><p>IDC有一些符号是提前定义好了的，其内容和含义如下：</p><pre><code class="hljs bash">_NT_           IDA is running under MS Windows_LINUX_        IDA is running under Linux_MAC_          IDA is running under Mac OS X_UNIX_         IDA is running under Unix (linux or mac)_EA64_         64-bit version IDA_QT_           GUI version of IDA (Qt)_GUI           GUI version of IDA_TXT_          Text version of IDA_IDA_VERSION_  The current IDA version. For example: <span class="hljs-string">&quot;7.5&quot;</span>_IDAVER_       The current, numerical IDA version. For example: <span class="hljs-string">&quot;750&quot;</span> means v7.5</code></pre><h4 id="IDC字符串操作（切片）"><a href="#IDC字符串操作（切片）" class="headerlink" title="IDC字符串操作（切片）"></a>IDC字符串操作（切片）</h4><p>IDC中对于字符串的操作应该是借鉴了python，其string类型的操作支持切片操作（slices）。</p><pre><code class="hljs bash">str[i1:i2] - substring from i1 to i2. i2 is excluded，If i1 &gt;= i2, empty string is returned.str[idx]   - one character substring at <span class="hljs-string">&#x27;idx&#x27;</span>.             this is equivalent to str[idx:idx+1]str[:idx]  - substring from the beginning of the string to idx             this is equivalent to str[0:idx]str[idx:]  - substring from idx to the end of the string             this is equivalent to str[idx:0x7fffffff]</code></pre><h4 id="IDC异常处理"><a href="#IDC异常处理" class="headerlink" title="IDC异常处理"></a>IDC异常处理</h4><p>IDC异常处理中，可以使用的表达语句：</p><pre><code class="hljs bash">      auto e;      try       &#123;        ... some statements that cause a runtime error...      &#125;      catch ( e )      &#123;        // e holds the exception information        // it is an instance of the exception class      &#125;throw xx;  <span class="hljs-comment">#抛出</span></code></pre><h4 id="IDC程序"><a href="#IDC程序" class="headerlink" title="IDC程序"></a>IDC程序</h4><p>如果只是需要进行简单的查询或者查看，可以直接编写个别行的函数完成编写，但是如果一个脚本应用需要执行大量的IDC程序，并且还可能会在很多场景下需要重复使用，那么我们可能需要创建一个独立的IDC程序文件。<br>IDC程序文件要求用户使用用户定义的函数，并且至少定义一个没有参数的main函数，此外主程序文件中必须包含idc.idc头文件。</p><pre><code class="hljs c"><span class="hljs-meta">#idc程序文件基本结构</span>#Include &lt;idc.idc&gt;<span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;   Message(<span class="hljs-string">&quot;this is a IDC scipt file&quot;</span>);&#125;</code></pre><pre><code class="hljs bash">IDC支持如下C预处理指令：<span class="hljs-comment">#include &lt;文件&gt; ；将指定的文件包含在当前文件中</span><span class="hljs-comment">#define &lt;宏名称&gt;[可选项] ；创建宏，可以选择给宏分配指定的值</span><span class="hljs-comment">#ifdef &lt;名称&gt;; 测试指定的宏是否存在</span><span class="hljs-comment">#else 与ifdef一起使用</span><span class="hljs-comment">#endif 通过ifdef指定定义终止符</span><span class="hljs-comment">#undef &lt;名称&gt; ；删除指定的宏</span></code></pre><h4 id="常用idc函数"><a href="#常用idc函数" class="headerlink" title="常用idc函数"></a>常用idc函数</h4><h6 id="读取和修改数据的函数"><a href="#读取和修改数据的函数" class="headerlink" title="读取和修改数据的函数"></a>读取和修改数据的函数</h6><p>下面这些函数可用于访问IDA数据库中的各个字节、字及双字。</p><ul><li>long Byte(long addr): 从虚拟地址addr处读取一个字节（1字节）的值。</li><li>long Word(long addr): 从虚拟地址addr处读取一个字节（2字节）的值。</li><li>long Dword(long addr): 从虚拟地址addr处读取一个双字（4字节）的值。</li><li>void PatchByte(long addr,long val): 设置虚拟地址addr处一个字节（1字节）的值为val。</li><li>void PatchWord(long addr,long val): 设置虚拟地址addr处一个字节（2字节）的值为val。</li><li>void PatchDword(long addr,long val): 设置虚拟地址addr处一个双字（4字节）的值为val。</li><li>bool isLoaded(long addr): 如果虚拟地址addr中包含有效数据则返回，否则返回0。<h6 id="用户交互函数"><a href="#用户交互函数" class="headerlink" title="用户交互函数"></a>用户交互函数</h6>idc脚本没有任何调试工具，所以可以依靠输出函数实现调试。<br><img src="https://img-blog.csdnimg.cn/5a33ddc47f8a48a0af5be8e77f83be08.png" alt="一个个打太多了，别人总结好的"></li></ul><h6 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h6><p><img src="https://img-blog.csdnimg.cn/bc602657d9ec43a0aea0e64a308a2085.png" alt="在这里插入图片描述"></p><h6 id="数据库名称操作函数"><a href="#数据库名称操作函数" class="headerlink" title="数据库名称操作函数"></a>数据库名称操作函数</h6><p><img src="https://img-blog.csdnimg.cn/8aaa9c7fd18f4e3b9d932455f5b7733a.png" alt="在这里插入图片描述"></p><h6 id="处理函数的函数"><a href="#处理函数的函数" class="headerlink" title="处理函数的函数"></a>处理函数的函数</h6><p><img src="https://img-blog.csdnimg.cn/1c3b1c0afc194ea180a217184b99cedd.png" alt="在这里插入图片描述"></p><h6 id="代码交叉引用函数"><a href="#代码交叉引用函数" class="headerlink" title="代码交叉引用函数"></a>代码交叉引用函数</h6><p><img src="https://img-blog.csdnimg.cn/0ca0998cdf154bdf894f88c093b52630.png" alt="在这里插入图片描述"></p><h6 id="数据交叉引用函数"><a href="#数据交叉引用函数" class="headerlink" title="数据交叉引用函数"></a>数据交叉引用函数</h6><p><img src="https://img-blog.csdnimg.cn/18d94a93b590495f90a5eb18dc98b26d.png" alt="在这里插入图片描述"></p><h6 id="数据库操纵函数"><a href="#数据库操纵函数" class="headerlink" title="数据库操纵函数"></a>数据库操纵函数</h6><p><img src="https://img-blog.csdnimg.cn/3d52ee410bad4055bcc87821feab1cae.png" alt="在这里插入图片描述"></p><h6 id="数据库搜素函数"><a href="#数据库搜素函数" class="headerlink" title="数据库搜素函数"></a>数据库搜素函数</h6><p><img src="https://img-blog.csdnimg.cn/a1167f75c7564f9786b699f8c5803280.png" alt="在这里插入图片描述"></p><h6 id="反汇编行组件"><a href="#反汇编行组件" class="headerlink" title="反汇编行组件"></a>反汇编行组件</h6><p><img src="https://img-blog.csdnimg.cn/1abba0cd47214fc3af9a307cb84f632f.png" alt="在这里插入图片描述"></p><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><h6 id="简单的IF语句"><a href="#简单的IF语句" class="headerlink" title="简单的IF语句"></a>简单的IF语句</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> CurrAddress = ScreenEA();     <span class="hljs-keyword">if</span>(CurrAddress == <span class="hljs-number">0x401161</span>)    &#123;       Message(<span class="hljs-string">&quot;程序OEP =&gt; 0x%x \n&quot;</span>,CurrAddress);    &#125;    <span class="hljs-keyword">else</span>    &#123;      Message(<span class="hljs-string">&quot;没有扎到OEP \n&quot;</span>);    &#125;&#125;</code></pre><h6 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> origEA,currEA,funcStart,funcEnd;        origEA = ScreenEA();    <span class="hljs-comment">// origEA = OEP 如果origEA 不在函数内则返回-1</span>    funcStart = GetFunctionAttr(origEA,FUNCATTR_START);        funcEnd = GetFunctionAttr(origEA,FUNCATTR_END);        <span class="hljs-comment">//Message(&quot;OEP: %x 起始地址: %x --&gt; 结束地址: %x \n&quot;,origEA,funcStart,funcEnd);</span>        <span class="hljs-comment">// NextHead 在currEA开始的位置寻找下一条指令的地址</span>    <span class="hljs-keyword">for</span>(currEA = funcStart; currEA != <span class="hljs-number">-1</span>; currEA=NextHead(currEA,funcEnd))    &#123;        Message(<span class="hljs-string">&quot;--&gt; %8x \n&quot;</span>,currEA);    &#125;&#125;</code></pre><h6 id="while语句实现"><a href="#while语句实现" class="headerlink" title="while语句实现"></a>while语句实现</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> origEA,currEA,funcStart,funcEnd;        origEA = ScreenEA();    <span class="hljs-comment">// origEA = OEP 如果origEA 不在函数内则返回-1</span>    funcStart = GetFunctionAttr(origEA,FUNCATTR_START);        funcEnd = GetFunctionAttr(origEA,FUNCATTR_END);        <span class="hljs-comment">//Message(&quot;OEP: %x 起始地址: %x --&gt; 结束地址: %x \n&quot;,origEA,funcStart,funcEnd);</span>        <span class="hljs-keyword">while</span>(currEA != BADADDR)    &#123;        Message(<span class="hljs-string">&quot;--&gt; %x \n&quot;</span>,currEA);        currEA = NextHead(currEA,funcEnd);    &#125;&#125;</code></pre><h6 id="idc函数"><a href="#idc函数" class="headerlink" title="idc函数"></a>idc函数</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-comment">// 定义一个函数</span><span class="hljs-type">static</span> <span class="hljs-title function_">OutPutAddress</span><span class="hljs-params">(MyString)</span>&#123;    <span class="hljs-keyword">auto</span> currAddress;    currAddress = ScreenEA();    Message(<span class="hljs-string">&quot;%d \n&quot;</span>,MyString);    <span class="hljs-keyword">return</span> currAddress;&#125;<span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> ret = OutPutAddress(<span class="hljs-number">123</span>);    Message(<span class="hljs-string">&quot;%x \n&quot;</span>,ret);    &#125;</code></pre><h6 id="idc获取函数名"><a href="#idc获取函数名" class="headerlink" title="idc获取函数名"></a>idc获取函数名</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> origEA,currEA,funcStart,funcEnd;        origEA = ScreenEA();    <span class="hljs-comment">// origEA = OEP 如果origEA 不在函数内则返回-1</span>    funcStart = GetFunctionAttr(origEA,FUNCATTR_START);        funcEnd = GetFunctionAttr(origEA,FUNCATTR_END);        <span class="hljs-comment">//Message(&quot;OEP: %x 起始地址: %x --&gt; 结束地址: %x \n&quot;,origEA,funcStart,funcEnd);</span>        <span class="hljs-keyword">while</span>(currEA != BADADDR)    &#123;        Message(<span class="hljs-string">&quot;--&gt; %x name: %s \n&quot;</span>,currEA,GetFunctionName(currEA));        currEA = NextHead(currEA,funcEnd);    &#125;&#125;</code></pre><h6 id="idc枚举所有函数"><a href="#idc枚举所有函数" class="headerlink" title="idc枚举所有函数"></a>idc枚举所有函数</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> currAddr,func,endSeg,funcName,counter;        currAddr = ScreenEA();    func = SegStart(currAddr);    endSeg = SegEnd(currAddr);        Message(<span class="hljs-string">&quot;%x --&gt; %x \n&quot;</span>,func,endSeg);        counter = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(func != BADADDR &amp;&amp; func &lt; endSeg)    &#123;        funcName = GetFunctionName(func);        <span class="hljs-keyword">if</span>(funcName != <span class="hljs-string">&quot; &quot;</span>)        &#123;            Message(<span class="hljs-string">&quot;%x --&gt; %s \n&quot;</span>,func,funcName);            counter++;        &#125;        func = NextFunction(func);    &#125;     &#125;</code></pre><h6 id="枚举指定函数并输出"><a href="#枚举指定函数并输出" class="headerlink" title="枚举指定函数并输出"></a>枚举指定函数并输出</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> currAddr,func,endSeg,funcName,counter;        currAddr = ScreenEA();    func = SegStart(currAddr);    endSeg = SegEnd(currAddr);        Message(<span class="hljs-string">&quot;%x --&gt; %x \n&quot;</span>,func,endSeg);        counter = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(func != BADADDR &amp;&amp; func &lt; endSeg)    &#123;        funcName = GetFunctionName(func);        <span class="hljs-keyword">if</span>(funcName != <span class="hljs-string">&quot; &quot;</span>)        &#123;                    <span class="hljs-keyword">if</span>(funcName == <span class="hljs-string">&quot;__lock&quot;</span>)            &#123;                Message(<span class="hljs-string">&quot;%x --&gt; %s \n&quot;</span>,func,funcName);            &#125;                        counter++;        &#125;        func = NextFunction(func);    &#125;&#125;</code></pre><h6 id="寻找特殊指令，并高亮显示"><a href="#寻找特殊指令，并高亮显示" class="headerlink" title="寻找特殊指令，并高亮显示"></a>寻找特殊指令，并高亮显示</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-keyword">auto</span> head, op;    head = NextHead(<span class="hljs-number">0x00000000</span>, <span class="hljs-number">0xFFFFFFFF</span>);    <span class="hljs-keyword">while</span> ( head != BADADDR )    &#123;        op = GetMnem(head);        Message(<span class="hljs-string">&quot;%x %s \n&quot;</span>,head,op);                <span class="hljs-keyword">if</span> ( op == <span class="hljs-string">&quot;jmp&quot;</span> || op == <span class="hljs-string">&quot;call&quot;</span> )            SetColor(head, CIC_ITEM, <span class="hljs-number">0x010187</span>);                    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;xor&quot;</span>)            SetColor(head, CIC_ITEM, <span class="hljs-number">0x010198</span>);        head = NextHead(head, <span class="hljs-number">0xFFFFFFFF</span>);    &#125;&#125;</code></pre><h6 id="ida-dump"><a href="#ida-dump" class="headerlink" title="ida dump"></a>ida dump</h6><p>将函数dump到本地</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">getFuncName</span><span class="hljs-params">(ea)</span>&#123;    <span class="hljs-keyword">auto</span> funcName = get_func_name(ea);          <span class="hljs-keyword">auto</span> dm = demangle_name(funcName, get_inf_attr(INF_LONG_DN));    <span class="hljs-keyword">if</span>(dm != <span class="hljs-number">0</span>)    &#123;        funcName = dm;    &#125;    <span class="hljs-keyword">return</span> funcName;&#125;<span class="hljs-type">static</span> <span class="hljs-title function_">functionDump</span><span class="hljs-params">(ea)</span>&#123;    <span class="hljs-keyword">auto</span> funcName = <span class="hljs-number">0</span>;    <span class="hljs-keyword">auto</span> end = <span class="hljs-number">0x0</span>;    <span class="hljs-keyword">auto</span> file_open = get_idb_path()[<span class="hljs-number">0</span>:<span class="hljs-number">-4</span>] + <span class="hljs-string">&quot;_dump.log&quot;</span>;    <span class="hljs-keyword">auto</span> stream = fopen(file_open, <span class="hljs-string">&quot;w&quot;</span>);    <span class="hljs-keyword">auto</span> peekAhead;    <span class="hljs-keyword">while</span>( ea != BADADDR )    &#123;        ea = NextFunction(ea);              peekAhead = NextFunction(ea);        end = FindFuncEnd(ea);           funcName = getFuncName(ea);        <span class="hljs-keyword">if</span>(peekAhead == BADADDR)        &#123;            <span class="hljs-built_in">fprintf</span>(stream, <span class="hljs-string">&quot;&#123; 0x%X, 0x%X, \&quot;%s\&quot; &#125;\n&quot;</span>, ea, end, funcName);            ea = peekAhead;            <span class="hljs-keyword">continue</span>;        &#125;            end = peekAhead - <span class="hljs-number">1</span>;                  <span class="hljs-built_in">fprintf</span>(stream, <span class="hljs-string">&quot;&#123; 0x%X, 0x%X, \&quot;%s\&quot; &#125;\n&quot;</span>, ea, end,funcName);    &#125;        fclose(stream);&#125;<span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    functionDump(<span class="hljs-number">0x40000</span>);&#125;</code></pre><h6 id="全量反汇编："><a href="#全量反汇编：" class="headerlink" title="全量反汇编："></a>全量反汇编：</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-keyword">auto</span> decode = <span class="hljs-number">0x401000</span>;    <span class="hljs-keyword">auto</span> xref;        <span class="hljs-keyword">for</span>(xref = RfirstB(decode); xref != BADADDR; xref = RnextB(decode,xref))    &#123;         Message(<span class="hljs-string">&quot;xref: %x\n&quot;</span>,xref);        <span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>;      <span class="hljs-keyword">auto</span> inst = xref;    <span class="hljs-keyword">auto</span> op;                       <span class="hljs-keyword">while</span>((i &lt; <span class="hljs-number">100</span>) )       &#123;        inst = FindCode(inst,<span class="hljs-number">0x00</span>); <span class="hljs-comment">// flag set to backwards</span>      op = GetDisasm(inst); <span class="hljs-comment">// get</span>            Message(<span class="hljs-string">&quot;%x --&gt; %s \n&quot;</span>,inst,op);        i++;       &#125;    &#125; &#125;</code></pre><h6 id="查找特定指令片段"><a href="#查找特定指令片段" class="headerlink" title="查找特定指令片段"></a>查找特定指令片段</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> currAddr,startSeg,endSeg;        currAddr = ScreenEA();    startSeg = SegStart(currAddr);    endSeg = SegEnd(currAddr);        Message(<span class="hljs-string">&quot;OEP = %x 起始地址: %x 结束地址: %x \n&quot;</span>,currAddr,startSeg,endSeg);        <span class="hljs-keyword">while</span>(startSeg &lt; endSeg)    &#123;        <span class="hljs-keyword">auto</span> op = GetDisasm(startSeg);                <span class="hljs-comment">// 查找第一条指令</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(op,<span class="hljs-string">&quot;push    esi&quot;</span>)==<span class="hljs-number">0</span>)        &#123;            startSeg++;            op = GetDisasm(startSeg);            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(op,<span class="hljs-string">&quot;push    edi&quot;</span>))            &#123;                Message(<span class="hljs-string">&quot;特征: %x \n&quot;</span>,startSeg<span class="hljs-number">-1</span>);            &#125;        &#125;        startSeg++;    &#125;&#125;</code></pre><h6 id="全局数组操作："><a href="#全局数组操作：" class="headerlink" title="全局数组操作："></a>全局数组操作：</h6><p>数组是全局的，并写入数据库，白嫖完了，一定得释放</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">// 创建数组元素</span>    <span class="hljs-keyword">auto</span> array_ptr = CreateArray(<span class="hljs-string">&quot;array&quot;</span>);    <span class="hljs-comment">// 获取数组指针</span>    <span class="hljs-keyword">auto</span> ptr = GetArrayId(<span class="hljs-string">&quot;array&quot;</span>);        Message(<span class="hljs-string">&quot;获取到的操作指针: %x \n&quot;</span>,ptr);        <span class="hljs-comment">// 设置两个字符串变量</span>    SetArrayString(ptr,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;hello&quot;</span>);    SetArrayString(ptr,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;lyshark&quot;</span>);        <span class="hljs-comment">// 设置两个整数变量</span>    SetArrayLong(ptr,<span class="hljs-number">2</span>,<span class="hljs-number">100</span>);    SetArrayLong(ptr,<span class="hljs-number">3</span>,<span class="hljs-number">200</span>);        <span class="hljs-comment">// 如果提取字符串使用 AR_STR 标记 ，提取整数使用 AR_LONG</span>    <span class="hljs-keyword">auto</span> st = GetArrayElement(AR_STR,ptr,<span class="hljs-number">0</span>);    <span class="hljs-keyword">auto</span> st1 = GetArrayElement(AR_STR,ptr,<span class="hljs-number">1</span>);    Message(<span class="hljs-string">&quot;提取字符串变量: %s %s !\n&quot;</span>,st,st1);        <span class="hljs-keyword">auto</span> lo = GetArrayElement(AR_LONG,ptr,<span class="hljs-number">2</span>);    Message(<span class="hljs-string">&quot;提取整数变量: %d \n&quot;</span>,lo);        <span class="hljs-comment">// 删除数组的0号元素</span>    DelArrayElement(AR_STR,ptr,<span class="hljs-number">0</span>);    <span class="hljs-comment">// 注销整个数组</span>    DeleteArray(ptr);&#125;</code></pre><h6 id="字符串处理函数："><a href="#字符串处理函数：" class="headerlink" title="字符串处理函数："></a>字符串处理函数：</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">// 格式化字符串,类似于sprintf</span>    <span class="hljs-keyword">auto</span> name = form(<span class="hljs-string">&quot;hello %s&quot;</span>,<span class="hljs-string">&quot;lyshark&quot;</span>);    Message(<span class="hljs-string">&quot;格式化后的内容: %s \n&quot;</span>,name);        Message(<span class="hljs-string">&quot;十六进制转为整数: %d \n&quot;</span>,xtol(<span class="hljs-string">&quot;0x41&quot;</span>));    Message(<span class="hljs-string">&quot;十进制100转为八进制: %d \n&quot;</span>,ltoa(<span class="hljs-number">100</span>,<span class="hljs-number">8</span>));    Message(<span class="hljs-string">&quot;十进制100转换二进制: %d \n&quot;</span>,ltoa(<span class="hljs-number">100</span>,<span class="hljs-number">2</span>));    Message(<span class="hljs-string">&quot;字符A的ASCII: %d \n&quot;</span>,ord(<span class="hljs-string">&quot;A&quot;</span>));    Message(<span class="hljs-string">&quot;计算字符串长度: %d \n&quot;</span>,<span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;hello lyshark&quot;</span>));        <span class="hljs-comment">// 在著字符串中寻找子串</span>    <span class="hljs-keyword">auto</span> main = <span class="hljs-string">&quot;hello lyshark&quot;</span>;    <span class="hljs-keyword">auto</span> sub = <span class="hljs-string">&quot;lyshark&quot;</span>;    Message(<span class="hljs-string">&quot;寻找子串: %d \n&quot;</span>,<span class="hljs-built_in">strstr</span>(main,sub));&#125;</code></pre><h6 id="反汇编函数："><a href="#反汇编函数：" class="headerlink" title="反汇编函数："></a>反汇编函数：</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">// 索索特征码</span>    <span class="hljs-keyword">auto</span> code = FindBinary(<span class="hljs-number">0x401020</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;55 8B EC&quot;</span>);    Message(<span class="hljs-string">&quot;%x \n&quot;</span>,code);    <span class="hljs-comment">// 反汇反汇编代码</span>    code = GetDisasm(<span class="hljs-number">0x401000</span>);    Message(<span class="hljs-string">&quot;%s \n&quot;</span>,code);        <span class="hljs-comment">// 反汇 位于地址处的指令</span>    code = GetMnem(<span class="hljs-number">0x401000</span>);    Message(<span class="hljs-string">&quot;%s \n&quot;</span>,code);        <span class="hljs-comment">// 反汇opcode</span>    code = GetOpnd(<span class="hljs-number">0x401070</span>,<span class="hljs-number">0</span>);    Message(<span class="hljs-string">&quot;%s \n&quot;</span>,code);&#125;</code></pre><h6 id="枚举函数（枚举栈帧）"><a href="#枚举函数（枚举栈帧）" class="headerlink" title="枚举函数（枚举栈帧）"></a>枚举函数（枚举栈帧）</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> addr,args,end,locals,frame,firstArg,name,ret;        <span class="hljs-keyword">for</span>(addr = NextFunction(addr); addr != BADADDR; addr = NextFunction(addr))    &#123;        name = Name(addr);        end = GetFunctionAttr(addr,FUNCATTR_END);        locals = GetFunctionAttr(addr,FUNCATTR_FRSIZE);        <span class="hljs-comment">// 得到栈帧大小</span>        frame = GetFrame(addr);        <span class="hljs-comment">// 栈中保存返回地址偏移量</span>        ret = GetMemberOffset(frame,<span class="hljs-string">&quot; r&quot;</span>);        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<span class="hljs-keyword">continue</span>;        firstArg = ret +<span class="hljs-number">4</span>;        args = GetStrucSize(frame) - firstArg;        Message(<span class="hljs-string">&quot;函数: %s 开始: 0x%x 结束: 0x%x 大小: %d bytes 栈帧: %d bytes (%d args) \n&quot;</span>,name,addr,end,locals,args,args/<span class="hljs-number">4</span>);    &#125;&#125;</code></pre><h6 id="检索交叉引用（全部）："><a href="#检索交叉引用（全部）：" class="headerlink" title="检索交叉引用（全部）："></a>检索交叉引用（全部）：</h6><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">auto</span> func,end,target,inst,name,flags,xref;        flags = SEARCH_DOWN | SEARCH_NEXT;        func = GetFunctionAttr(ScreenEA(),FUNCATTR_START);        <span class="hljs-keyword">if</span>(func != <span class="hljs-number">-1</span>)    &#123;        name =Name(func);        end = GetFunctionAttr(func,FUNCATTR_END);        <span class="hljs-keyword">for</span>(inst = func;inst &lt; end; inst = FindCode(inst,flags))        &#123;            <span class="hljs-keyword">for</span>(target = Rfirst(inst);target != BADADDR; target = Rnext(inst,target))            &#123;                xref = XrefType();                <span class="hljs-keyword">if</span>(xref == fl_CN || xref == fl_CF)                &#123;                    Message(<span class="hljs-string">&quot;%s call -&gt; %sfrom --&gt; %x \n&quot;</span>,name,Name(target),inst);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IDC&quot;&gt;&lt;a href=&quot;#IDC&quot; class=&quot;headerlink&quot; title=&quot;IDC&quot;&gt;&lt;/a&gt;IDC&lt;/h2&gt;&lt;p&gt;首先，什么是IDC？&lt;br&gt;IDC是IDA中支持的一门与C语言类似的语言，但是它是解释型的，并不是编译型的，于此同时IDC还融合了一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>memset()函数</title>
    <link href="https://hzy2003628.top/2023/02/23/memset%E5%87%BD%E6%95%B0/"/>
    <id>https://hzy2003628.top/2023/02/23/memset%E5%87%BD%E6%95%B0/</id>
    <published>2023-02-23T12:15:59.193Z</published>
    <updated>2023-02-23T12:19:49.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h1><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是memset函数的声明</p><pre><code class="hljs bash">void *memset(void *str, int c, size_t n)</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>str</strong>   –指向要填充的内存块</li><li><strong>c</strong>  –要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式</li><li><strong>n</strong>  –要被设置为该值的字符数</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>该值返回一个指向存储区 str 的指针</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;memset函数&quot;&gt;&lt;a href=&quot;#memset函数&quot; class=&quot;headerlink&quot; title=&quot;memset函数&quot;&gt;&lt;/a&gt;memset函数&lt;/h1&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>异或算法</title>
    <link href="https://hzy2003628.top/2023/02/23/%E5%BC%82%E6%88%96%E7%AE%97%E6%B3%95/"/>
    <id>https://hzy2003628.top/2023/02/23/%E5%BC%82%E6%88%96%E7%AE%97%E6%B3%95/</id>
    <published>2023-02-23T12:15:28.839Z</published>
    <updated>2023-02-21T13:02:00.409Z</updated>
    
    <content type="html"><![CDATA[<p>异或算法<br><strong>相同为0，不同为1</strong><br>异或的数学符号为”⊕”    在计算机中通常用”^”的符号表示   异或略称为XOR、EOR、EX-OR</p><p>用途：<br>1、交互两个数：a=5,b=10,用异或实现交换</p><p>程序代码：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;   <span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;   <span class="hljs-type">int</span> b=<span class="hljs-number">10</span>;   a=a^b;   b=a^b;<span class="hljs-comment">//   a=a^b;</span>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,a,b);   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>2、因为电脑的数都是二进制的，所以可以转化二进制的位数和统计二进制中1或者0是奇数还是偶数。</p><p>（1):位反转<br>举例：10001000 在一些情况下，第四位和第五位需要反转，可以用10001000与00011000进行异或运算。<br>10001000 ^ 00011000 = 10010000<br>(2):统计某一位的奇偶数<br>将某个元素中的每一位逐步异或.<br>例如a1=1010，则b1=1 ^ 0 ^ 1 ^ 0 = 0，由此可以判断a中为1的位数是奇数还是偶数。<br>例如a2=10110，则b2=1 ^ 0 ^ 1 ^ 1 ^ 0 =1，由此可以判断a中为1的位数是奇数还是偶数。</p><p>3、找出序列中单个最小的数字：</p><p>程序代码：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;   <span class="hljs-type">int</span> a,b,c,d,e,f,n,m;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);   n=a^b^c^d^e;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n);   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>扩展：&amp;（与）运算<br>都是1时结果才为1；<br>二进制与运算规则:1&amp;1=1 1&amp;0=0 0&amp;0=0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;异或算法&lt;br&gt;&lt;strong&gt;相同为0，不同为1&lt;/strong&gt;&lt;br&gt;异或的数学符号为”⊕”    在计算机中通常用”^”的符号表示   异或略称为XOR、EOR、EX-OR&lt;/p&gt;
&lt;p&gt;用途：&lt;br&gt;1、交互两个数：a=5,b=10,用异或实现交换&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常见文件头</title>
    <link href="https://hzy2003628.top/2023/02/23/%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E5%A4%B4/"/>
    <id>https://hzy2003628.top/2023/02/23/%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E5%A4%B4/</id>
    <published>2023-02-23T12:15:28.837Z</published>
    <updated>2023-02-21T13:06:44.786Z</updated>
    
    <content type="html"><![CDATA[<p>常见文件头：<br>文件类型：             文件头信息：                                    文件尾信息：<br>JPEG (jpg)             FFD8FFE0或FFD8FFE1或FFD8FFE8                    FF<br>PNG (png)             89 50 4E 47                                        00 3B<br>pdf                     25 50 44 46 2D 31 2E<br>Windows Password (pwl) E3 82 85 96<br>RAR                     52 61 72 21<br>ZIP Archive (zip)         50 4B 03 04                                        50 4B<br>压缩包                 PK<br>Word/Excel (xls.or.doc)     D0 CF 11 E0<br>HTML (html)             68 74 6D 6C 3E<br>MIDI (mid)              4D 54 68 64<br>7z                       37 7A BC AF 27 1C<br>GIF                       47 49 46 38 39 61<br>bmp                       42 4D 76 68</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常见文件头：&lt;br&gt;文件类型：             文件头信息：                                    文件尾信息：&lt;br&gt;JPEG (jpg)             FFD8FFE0或FFD8FFE1或FFD8FFE8        </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>寒假刷题记录reverse2</title>
    <link href="https://hzy2003628.top/2023/02/23/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95reverse2/"/>
    <id>https://hzy2003628.top/2023/02/23/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95reverse2/</id>
    <published>2023-02-23T12:15:28.835Z</published>
    <updated>2023-02-22T12:37:04.918Z</updated>
    
    <content type="html"><![CDATA[<p>攻防世界<br>Reverse</p><h2 id="1-Hello-CTF"><a href="#1-Hello-CTF" class="headerlink" title="1.Hello,CTF"></a>1.Hello,CTF</h2><p>拖入exe<br><img src="https://img-blog.csdnimg.cn/b457cb91e5a34c5ab9b32fdfc9a2e69d.png" alt="在这里插入图片描述"></p><p>无壳，拖入32位IDA<br>发现输入字符串大于17，程序结束0x11 = 17<br>小于17，则v10与v13比较，相同则输出：aSuccess<br>而v13一定大于17 ，v13=437261636b4d654a757374466f7246756e<br>进制转换，发现每位都在1-9 a-f之内，猜测为16位，转换如图<br><img src="https://img-blog.csdnimg.cn/2f43c3233bd44e0d96b42f7aaa388cf9.png" alt="在这里插入图片描述"></p><p>而题目描述为菜鸡发现Flag似乎并不一定是明文比较的<br>得到flag为CrackMeJustForFun</p><h2 id="2-re1"><a href="#2-re1" class="headerlink" title="2.re1"></a>2.re1</h2><p>拖入exe无壳，拖入32位IDA，找到main函数F5反汇编<br><img src="https://img-blog.csdnimg.cn/90ee01aa53454ba5a9a9a31f441a0421.png" alt="在这里插入图片描述"></p><p>看到有个strcmp函数，比较v5和v9,然后判断v3，根据v3给出相应的结果<br>双击跟进aFlagGet,证明思路正确<br>跟进xmmword_413E34<br><img src="https://img-blog.csdnimg.cn/d031e944ec5e46489bc9e532c9ce7eb0.png" alt="在这里插入图片描述"></p><p>xmmword的值已经出来了：那么v5的值就是3074656D30633165577B465443545544h了<br>v5应该是16进制表示的，看下strcmp函数，有个将v5转换为字符串的函数<br>找到在线16进制转换字符串<br><img src="https://img-blog.csdnimg.cn/4d4f001409f849949007daca55590259.png" alt="在这里插入图片描述"></p><p>通过文字倒序得到DUCTF{We1c0met0<br>发现flag并不完整，想到题干<br><img src="https://img-blog.csdnimg.cn/4d1dee139f08426c957feb7e1c8649a9.png" alt="在这里插入图片描述"></p><p>故猜测flag为DUCTF{We1c0met0DUCTF}</p><h2 id="3-logmein"><a href="#3-logmein" class="headerlink" title="3.logmein"></a>3.logmein</h2><p>拖入exe，无壳，拖入64位IDA,找到main函数，F5反汇编<br><img src="https://img-blog.csdnimg.cn/f9996af416644f7d87afd3da426b9ee3.png" alt="在这里插入图片描述"></p><p>__isoc99_scanf(“%32s”, s);<br>这一行代码就是我们输入的flag<br>将我们输入的flag的每一位与v7[i%v6]^v8[i]比较，如果有任意一位不相等，则输出“Incorrect password!”<br>把v7转换成字符型，IDA上直接显示的是<br>v7 = ‘ebmarah’;<br>需要注意的是，x86系列的CPU都是以小端序储存数据的，即低位字节存入低地址，高位字节存入高地址，所以正确的字符串应该反过来，即<br>v7=’harambe’;<br>脚本：</p><pre><code class="hljs python">v7 = <span class="hljs-string">&#x27;harambe&#x27;</span>v8 = <span class="hljs-string">&#x27;:\&quot;AL_RT^L*.?+6/46&#x27;</span>flag = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v8)):    c = <span class="hljs-built_in">ord</span>(v7[i % <span class="hljs-number">7</span>]) ^ <span class="hljs-built_in">ord</span>(v8[i])    flag += <span class="hljs-built_in">chr</span>(c)   <span class="hljs-built_in">print</span>(flag)</code></pre><p>得到flag为RC3-2016-XORISGUD</p><h2 id="4-Getit"><a href="#4-Getit" class="headerlink" title="4.Getit"></a>4.Getit</h2><p>拖入exe，无壳，拖入64位IDA<br><img src="https://img-blog.csdnimg.cn/bbe9df77a66d4ceb815af03c0d1615d2.png" alt="在这里插入图片描述"></p><p>双击跟进p[j]<br><img src="https://img-blog.csdnimg.cn/0303d3763ff34353a7800c9da436f80f.png" alt="在这里插入图片描述"></p><p>可以看到p[i]数组存放的是无序的整数，也就是说每次在/tmp/flag.txt文件中写入的flag是不按顺序写的，且每次只出现一个字符，需要自己排序。<br>双击跟进t<br><img src="https://img-blog.csdnimg.cn/184c2a3216064ead8d4537f695bd67eb.png" alt="在这里插入图片描述"></p><p>发现harifCTF{????????????????????????????????}<br>53h转换成字符串为‘S’<br>脚本：</p><pre><code class="hljs python">key1=<span class="hljs-string">&quot;c61b68366edeb7bdce3c6820314b7498&quot;</span>v5=<span class="hljs-number">0</span>flag=<span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">while</span> v5 &lt; <span class="hljs-built_in">len</span>(key1):   <span class="hljs-keyword">if</span> v5 &amp; <span class="hljs-number">1</span>:      v3=<span class="hljs-number">1</span>   <span class="hljs-keyword">else</span>:      v3=-<span class="hljs-number">1</span>   flag+=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(key1[v5])+v3)   v5+=<span class="hljs-number">1</span><span class="hljs-built_in">print</span>(flag)</code></pre><p>运行得到b70c59275fcfa8aebf2d5911223c6589<br>所以flag为SharifCTF{b70c59275fcfa8aebf2d5911223c6589}<br>看到的其他解法：<br>法二：GDB动态调试<br>首先我们知道了下面strlen(&amp;t)的t是flag程序运行后生成的flag,那我们把鼠标放在那一行上看一下下面的反汇编行数，如下所示是400824，那么我们在反汇编窗口跟上。<br><img src="https://img-blog.csdnimg.cn/4d86d12ccaaa46968f01ebbe30022052.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c0e9978a0508437ab0133ce9b1eca495.png" alt="在这里插入图片描述"></p><p>可以看到反汇编中400824行的确是_strlen函数，而它上面就是把&amp;t移入了edi，所以在GDB中我们断点400824，然后查看edi寄存器即可。<br>所需命令：</p><pre><code class="hljs bash">b *0x400824r</code></pre><p>这里用的是hyperpwn插件：<br><img src="https://img-blog.csdnimg.cn/70ca37c51c9a424eadcdd324b559ac52.png" alt="在这里插入图片描述"></p><p>可以看到flag就在RDI寄存器里<br>法三：C语言脚本</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(disable:4996)</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">char</span> v3;    __int64 v5;    <span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;c61b68366edeb7bdce3c6820314b7498&quot;</span>;    <span class="hljs-type">char</span> t[] = <span class="hljs-string">&quot;SharifCTF&#123;????????????????????????????????&#125;&quot;</span>;    v5 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (v5 &lt; <span class="hljs-built_in">strlen</span>(s)) &#123;        <span class="hljs-keyword">if</span> (v5 &amp; <span class="hljs-number">1</span>)            v3 = <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span>            v3 = <span class="hljs-number">-1</span>;        *(t + v5 + <span class="hljs-number">10</span>) = s[v5] + v3;        v5++;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, t);    system(<span class="hljs-string">&quot;PAUSE&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>法四：在IDA动态截停<br><img src="https://img-blog.csdnimg.cn/0e7b0af0d5b046ee9ddd551986b5322d.png" alt="在这里插入图片描述"></p><h2 id="5-no-strings-attached"><a href="#5-no-strings-attached" class="headerlink" title="5.no-strings-attached"></a>5.no-strings-attached</h2><p>拖入exe，无壳，拖入32位IDA<br>找到main函数，F5反汇编<br><img src="https://img-blog.csdnimg.cn/c2436ac16dc84454b28f8c4e081c281f.png" alt="在这里插入图片描述"></p><p>双击跟进authenticate()函数，分析如下</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">authenticate</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-type">wchar_t</span> ws[<span class="hljs-number">8192</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-800Ch]</span>  <span class="hljs-type">wchar_t</span> *s2; <span class="hljs-comment">// [esp+801Ch] [ebp-Ch]</span>  s2 = (<span class="hljs-type">wchar_t</span> *)<span class="hljs-built_in">decrypt</span>(&amp;s, &amp;dword_8048A90); <span class="hljs-comment">//decrypt表示加密</span>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">fgetws</span>(ws, <span class="hljs-number">0x2000</span>, stdin) ) <span class="hljs-comment">//进行输入</span>  &#123;    ws[<span class="hljs-built_in">wcslen</span>(ws) - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">wcscmp</span>(ws, s2) ) <span class="hljs-comment">//判断输入的ws是否等于加密过后的s2</span>      <span class="hljs-built_in">wprintf</span>((<span class="hljs-type">int</span>)&amp;unk_8048B44); <span class="hljs-comment">//如果ws=s2，得到unk_8048B44，跟进得到success！</span>    <span class="hljs-keyword">else</span>      <span class="hljs-built_in">wprintf</span>((<span class="hljs-type">int</span>)&amp;unk_8048BA4);  &#125;  <span class="hljs-built_in">free</span>(s2);&#125;</code></pre><p>当 ws 和 s2 相等时，会输出正确结果，那么s2就是flag，而s2经过了decrypt()加密。<br>那么跟进decrypt()函数：<br><img src="https://img-blog.csdnimg.cn/f125d44d7f9c4b60bd4f01bddd91c928.png" alt="在这里插入图片描述"></p><p>它先把参数 s 复制给 dest，与就是s=dest，然后把 dest 的每个值减去 a2 的值，然后再返回加密后的 dest。那么，我们就把s与a2找出来，相减就得到flag。<br>双击跟进s<br><img src="https://img-blog.csdnimg.cn/a47ebc5f861b4604a5041997032333a1.png" alt="在这里插入图片描述"></p><p>选中按shift+e提取出来<br><img src="https://img-blog.csdnimg.cn/5052a2a23fe444b481c02e776fe30693.png" alt="在这里插入图片描述"></p><p>根据得到的信息写c脚本：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;    <span class="hljs-type">int</span> s[] =    &#123;      <span class="hljs-number">58</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,  <span class="hljs-number">54</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,  <span class="hljs-number">55</span>,  <span class="hljs-number">20</span>,       <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,  <span class="hljs-number">59</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">128</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,     <span class="hljs-number">122</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">113</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">120</span>,  <span class="hljs-number">20</span>,       <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,  <span class="hljs-number">99</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">102</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,     <span class="hljs-number">115</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">103</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,  <span class="hljs-number">98</span>,  <span class="hljs-number">20</span>,       <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">101</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">115</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,      <span class="hljs-number">96</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">107</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">113</span>,  <span class="hljs-number">20</span>,       <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">120</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">106</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,     <span class="hljs-number">115</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">112</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">100</span>,  <span class="hljs-number">20</span>,       <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">120</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">110</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,     <span class="hljs-number">112</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">112</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">100</span>,  <span class="hljs-number">20</span>,       <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">112</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">100</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,     <span class="hljs-number">110</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">123</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">118</span>,  <span class="hljs-number">20</span>,       <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">120</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">106</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,     <span class="hljs-number">115</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">123</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">128</span>,  <span class="hljs-number">20</span>,       <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,    &#125;;    <span class="hljs-type">int</span> b[] =    &#123;       <span class="hljs-number">1</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">2</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">3</span>,  <span class="hljs-number">20</span>,       <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">20</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,    &#125;;    <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">152</span>)    &#123;       x = s[i ++] - b[j ++ % <span class="hljs-number">20</span>];       <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">32</span>)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,x);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/3c3255adc03e48c1874633d7327b7a99.png" alt="在这里插入图片描述"><br>得到flag为9447{you_are_an_international_mystery}<br>python脚本为：</p><pre><code class="hljs python">s = [<span class="hljs-number">5178</span>, <span class="hljs-number">5174</span>, <span class="hljs-number">5175</span>, <span class="hljs-number">5179</span>, <span class="hljs-number">5248</span>, <span class="hljs-number">5242</span>, <span class="hljs-number">5233</span>, <span class="hljs-number">5240</span>, <span class="hljs-number">5219</span>, <span class="hljs-number">5222</span>, <span class="hljs-number">5235</span>, <span class="hljs-number">5223</span>, <span class="hljs-number">5218</span>, <span class="hljs-number">5221</span>, <span class="hljs-number">5235</span>, <span class="hljs-number">5216</span>, <span class="hljs-number">5227</span>, <span class="hljs-number">5233</span>, <span class="hljs-number">5240</span>, <span class="hljs-number">5226</span>, <span class="hljs-number">5235</span>, <span class="hljs-number">5232</span>, <span class="hljs-number">5220</span>, <span class="hljs-number">5240</span>, <span class="hljs-number">5230</span>, <span class="hljs-number">5232</span>, <span class="hljs-number">5232</span>, <span class="hljs-number">5220</span>, <span class="hljs-number">5232</span>, <span class="hljs-number">5220</span>, <span class="hljs-number">5230</span>, <span class="hljs-number">5243</span>, <span class="hljs-number">5238</span>, <span class="hljs-number">5240</span>, <span class="hljs-number">5226</span>, <span class="hljs-number">5235</span>, <span class="hljs-number">5243</span>, <span class="hljs-number">5248</span>]a = [<span class="hljs-number">5121</span>, <span class="hljs-number">5122</span>, <span class="hljs-number">5123</span>, <span class="hljs-number">5124</span>, <span class="hljs-number">5125</span>]v6 = <span class="hljs-built_in">len</span>(s)v7 = <span class="hljs-built_in">len</span>(a )v2 = <span class="hljs-built_in">len</span>(s)v4=<span class="hljs-number">0</span><span class="hljs-keyword">while</span> v4&lt;v6:        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>):        <span class="hljs-keyword">if</span>(i&lt;v7 <span class="hljs-keyword">and</span> v4&lt;v6):            s[v4]-=a[i]            v4 += <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">break</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">38</span>):    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(s[i]),end=<span class="hljs-string">&quot;&quot;</span>)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;攻防世界&lt;br&gt;Reverse&lt;/p&gt;
&lt;h2 id=&quot;1-Hello-CTF&quot;&gt;&lt;a href=&quot;#1-Hello-CTF&quot; class=&quot;headerlink&quot; title=&quot;1.Hello,CTF&quot;&gt;&lt;/a&gt;1.Hello,CTF&lt;/h2&gt;&lt;p&gt;拖入exe&lt;br&gt;&lt;i</summary>
      
    
    
    
    <category term="刷题" scheme="https://hzy2003628.top/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="寒假刷题记录" scheme="https://hzy2003628.top/tags/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>寒假刷题记录misc</title>
    <link href="https://hzy2003628.top/2023/02/23/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95misc/"/>
    <id>https://hzy2003628.top/2023/02/23/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95misc/</id>
    <published>2023-02-23T12:15:28.833Z</published>
    <updated>2023-02-22T12:37:33.163Z</updated>
    
    <content type="html"><![CDATA[<p>攻防世界<br>Misc</p><h2 id="1-2017-Dating-in-Singapore"><a href="#1-2017-Dating-in-Singapore" class="headerlink" title="1.2017_Dating_in_Singapore"></a>1.2017_Dating_in_Singapore</h2><p>手动格式化一下得到<br><img src="https://img-blog.csdnimg.cn/40918f9697684313869e28c2399f5bc9.png" alt="在这里插入图片描述"></p><p>每行长度分别为<br>26位<br>18位<br>16位<br>26位<br>14位<br>16位<br>16位<br>22位<br>20位<br>22位<br>18位<br>14位<br>通过分隔符可以分12行，都是十进制数<br>2位分隔得到<br><img src="https://img-blog.csdnimg.cn/6dcbef4b8b924e32876336282c267a76.png" alt="在这里插入图片描述"></p><p>在假设按每一行顺序对应每一个月份的情况下，每一个数字对应日期便可以得到<br><img src="https://img-blog.csdnimg.cn/3c534954721545ffb058b934d1f18a06.png" alt="在这里插入图片描述"></p><p>得到flag为HTIB{CTFFUN}</p><h2 id="2-Training-Stegano-1"><a href="#2-Training-Stegano-1" class="headerlink" title="2.Training-Stegano-1"></a>2.Training-Stegano-1</h2><p>拖入010<br><img src="https://img-blog.csdnimg.cn/eb30b503405741c5abc5e408e37dd35b.png" alt="在这里插入图片描述"></p><p>得到flag为steganol</p><h2 id="3-can-has-stdio"><a href="#3-can-has-stdio" class="headerlink" title="3.can_has_stdio?"></a>3.can_has_stdio?</h2><p>用记事本打开<br>了解到这是brainfuck语言<br>在线解密CTF在线工具-在线Brainfuck加密|在线Brainfuck解密|Brainfuck|Brainfuck原理|Brainfuck算法 (hiencode.com)<br><img src="https://img-blog.csdnimg.cn/8c14acb057454d59a5ed9bdd1c4374db.png" alt="在这里插入图片描述"></p><p>得到flag{esolangs_for_fun_and_profit}</p><h2 id="4-Test-flag-please-ignore"><a href="#4-Test-flag-please-ignore" class="headerlink" title="4.Test-flag-please-ignore"></a>4.Test-flag-please-ignore</h2><p>用记事本打开得到：<br>666c61677b68656c6c6f5f776f726c647d<br>在线16进制转字符串<a href="http://www.bejson.com/convert/ox2str/">http://www.bejson.com/convert/ox2str/</a><br>得到flag{hello_world}</p><h2 id="5-reversemMe"><a href="#5-reversemMe" class="headerlink" title="5.reversemMe"></a>5.reversemMe</h2><p>打开发现是一张镜像的flag<br>因为没有photoshop,所以直接看的<br>得到flag{4f7548f93c7bef1dc6a0542cf04e796e}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;攻防世界&lt;br&gt;Misc&lt;/p&gt;
&lt;h2 id=&quot;1-2017-Dating-in-Singapore&quot;&gt;&lt;a href=&quot;#1-2017-Dating-in-Singapore&quot; class=&quot;headerlink&quot; title=&quot;1.2017_Dating_in_Sin</summary>
      
    
    
    
    <category term="刷题" scheme="https://hzy2003628.top/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="寒假刷题记录" scheme="https://hzy2003628.top/tags/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>寒假刷题记录reverse1</title>
    <link href="https://hzy2003628.top/2023/02/23/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%951reverse/"/>
    <id>https://hzy2003628.top/2023/02/23/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%951reverse/</id>
    <published>2023-02-23T12:15:28.830Z</published>
    <updated>2023-02-22T12:38:08.168Z</updated>
    
    <content type="html"><![CDATA[<p>攻防世界</p><h2 id="1-Reversing-x64Elf-100"><a href="#1-Reversing-x64Elf-100" class="headerlink" title="1.Reversing-x64Elf-100"></a>1.Reversing-x64Elf-100</h2><p>拖入EXE中查看信息<br><img src="https://img-blog.csdnimg.cn/e500a6b46f614f71904da1d6fae2cc7a.png" alt="在这里插入图片描述"></p><p>拖入64位IDA<br><img src="https://img-blog.csdnimg.cn/f2753ea6b0024398b05baa580d0986aa.png" alt="在这里插入图片描述"></p><p>双击进入main函数，F5查看伪代码<br><img src="https://img-blog.csdnimg.cn/a24506c0d7b848b88f18dc00d28cd150.png" alt="在这里插入图片描述"></p><p>双击跟进sub_400FD<br><img src="https://img-blog.csdnimg.cn/06853083e5c84a7f965b9eed4c89249a.png" alt="在这里插入图片描述"></p><p>编写脚本<br><img src="https://img-blog.csdnimg.cn/4db3912b39664755ab6523df7830e63f.png" alt="在这里插入图片描述"></p><p>得到flag为Code_Talkers</p><h2 id="2-666"><a href="#2-666" class="headerlink" title="2.666"></a>2.666</h2><p>下载附件并解压，解压后文件拖入exe<br><img src="https://img-blog.csdnimg.cn/78eff035106449c08509a9ec0afd732e.png" alt="在这里插入图片描述"></p><p>拖入64位IDA<br>找到主函数，F5<br><img src="https://img-blog.csdnimg.cn/adeb4d30c8fe4faea67ddda1339e5cee.png" alt="在这里插入图片描述"></p><p>v5是需要输入的内容，v5的长度等于key，用s和enflag进行比较，相等就输出You are Right .<br>观察encode函数<br><img src="https://img-blog.csdnimg.cn/416a4ba648654bc4af9437dff2f220de.png" alt="在这里插入图片描述"></p><p>a1即为主函数中的v5，a2即为主函数中的s,对a1进行处理可以得到a2，根据循环可写逆过程<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</p><p>int main()<br>{<br>    char a1[20],a2[20]={“izwhroz&quot;&quot;w&quot;v.K&quot;.Ni”},v3[32],v4[32],v5[40];<br>    int v6,i;<br>    i=0;<br>    v6=0;<br>    for(i=15;i&gt;=0;i-=3)<br>    {<br>        v3[i+2]=a2[i+2];<br>        v4[i+1]=a2[i+1];<br>        v5[i]=a2[i];<br>        a1[i+2]=v3[i+2]^18^6;<br>        a1[i+1]=(v4[i+1]^18)+6;<br>        a1[i]=(18^v5[i])-6;<br>    }<br>    a1[18]=’\0’;<br>    printf(“%s”,a1);<br>    return 0;<br>}<br>运行得到flag为unctf{b66_6b6_66b}</p><h2 id="3-easyRE1"><a href="#3-easyRE1" class="headerlink" title="3.easyRE1"></a>3.easyRE1</h2><p>解压文件后得到两个文件分别拖入32位和64位IDA，F5后发现主函数相同且直接得到flag<br><img src="https://img-blog.csdnimg.cn/f650c88fd4434965a7548638888bb262.png" alt="在这里插入图片描述"></p><p>flag为flag{db2f62a36a018bce28e46d976e3f9864}</p><h2 id="4-Lucknum"><a href="#4-Lucknum" class="headerlink" title="4.Lucknum"></a>4.Lucknum</h2><p>下载附件并解压，拖入exe<br><img src="https://img-blog.csdnimg.cn/962138de56504079ac1aaf48a4a248c1.png" alt="在这里插入图片描述"></p><p>拖入64位IDA，F5后直接可找到flag<br><img src="https://img-blog.csdnimg.cn/41ccd0ec108b4ae9903a47fde8d9b37d.png" alt="在这里插入图片描述"></p><p>flag为flag{c0ngr@tul@ti0n_f0r_luck_numb3r}</p><h2 id="5-reverse-re3"><a href="#5-reverse-re3" class="headerlink" title="5.reverse_re3"></a>5.reverse_re3</h2><p>下载附件并解压，拖入exe<br><img src="https://img-blog.csdnimg.cn/23afb6502cd148aea4538eb12b1ebc23.png" alt="在这里插入图片描述"></p><p>拖入64位IDA<br>找到main函数，F5后双击跟进v4=sub_940()<br>快捷键R转化为字符发现分别出现wasd，猜测为迷宫游戏<br>v5 = __readfsqword(0x28u);<br>  v3 = 0;<br>  memset(v4, 0, 0x200uLL);<br>  _isoc99_scanf(&amp;unk_1278, v4, v4);<br>  while ( 1 )<br>  {<br>    do<br>    {<br>      v2 = 0;<br>      sub_86C();<br>      v0 = v4[v3];<br>      if ( v0 == ‘d’ )<br>      {<br>        v2 = sub_E23();<br>      }<br>      else if ( v0 &gt; ‘d’ )<br>      {<br>        if ( v0 == ‘s’ )<br>        {<br>          v2 = sub_C5A();<br>        }<br>        else if ( v0 == ‘w’ )<br>        {<br>          v2 = sub_A92();<br>        }<br>      }<br>      else<br>      {<br>        if ( v0 == 27 )<br>          return 0xFFFFFFFFLL;<br>        if ( v0 == ‘a’ )<br>          v2 = sub_FEC();<br>      }<br>      ++v3;<br>    }<br>    while ( v2 != 1 );<br>    if ( dword_202AB0 == 2 )<br>      break;<br>    ++dword_202AB0;<br>  }<br>  puts(“success! the flag is flag{md5(your input)}”);<br>  return 1LL;<br>}<br>分别进入函数体内<br>双击Sub_E23<br>双击dword202020<br><img src="https://img-blog.csdnimg.cn/80042cf20a324edbb2897ddda0095c3c.png" alt="在这里插入图片描述"></p><p>提取数据，shift+e<br>因为数组是dword类型 所以应该四个为一组 只有第一个为有效值，后面的都是补0<br><img src="https://img-blog.csdnimg.cn/f3f5d562872541ed9f06f23252d991d7.png" alt="在这里插入图片描述"></p><p>这时候可以在Export as下选择倒数第二个选项 initialized C variable<br>提取出来的补0就没有了<br>一个迷宫应该是15x15 =225<br>根据提取出的数组大小675 可以知道<br>675=225*3三个迷宫<br>处理后，得到如下迷宫<br>第一个迷宫<br>[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br>[1, 1, 1, 1, 1, 0, 3, 1, 1, 0, 0, 0, 0, 0, 0]<br>[1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]<br>[1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]<br>[1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0]<br>[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]<br>[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]<br>[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]<br>[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]<br>[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]<br>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>第二个迷宫<br>[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br>[1, 1, 0, 3, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]<br>[1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]<br>[1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]<br>[1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0]<br>[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]<br>[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]<br>[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]<br>[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]<br>[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]<br>[1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0]<br>[1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]<br>[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]<br>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>第三个迷宫<br>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br>[0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br>[0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]<br>[0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]<br>[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]<br>[0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]<br>[0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]<br>[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]<br>[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0]<br>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]<br>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]<br>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]<br>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]<br>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]<br>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]<br>“3”是起点，“4”是终点，“1”是可走的，“0”是不可走的<br> 最后将三个迷宫的解法，并在一起<br>ddsssddddsssdssdddddsssddddsssaassssdddsddssddwddssssssdddssssdddss<br>Md5解密MD5在线加密/解密/破解—MD5在线 (sojson.com)<br>得到flag{aeea66fcac7fa80ed8f79f38ad5bb953}</p><h2 id="6-1000Click"><a href="#6-1000Click" class="headerlink" title="6.1000Click"></a>6.1000Click</h2><p>拖入exe查壳，无壳<br>拖入32位IDA，shift+F12查看字符串，ctrl+f全局搜索flag<br><img src="https://img-blog.csdnimg.cn/7d2e91c3892d45769d3531c2a43eacc6.png" alt="在这里插入图片描述"></p><p>找到flag为flag{TIBntXVbdZ4Z9VRtoOQ2wR1vDNIjQ8Ra}</p><h2 id="7-crypt"><a href="#7-crypt" class="headerlink" title="7.crypt"></a>7.crypt</h2><p>拖入exe<br><img src="https://img-blog.csdnimg.cn/ae831b2b878c462bba7b5227f47e3749.png" alt="在这里插入图片描述"></p><p>拖入64位IDA<br>(5条消息) 攻防世界：crypt(RC4)_逆向技术分享的博客-CSDN博客</p><h2 id="8-happyctf"><a href="#8-happyctf" class="headerlink" title="8.happyctf"></a>8.happyctf</h2><p>拖入32位IDA，F5<br>int __thiscall sub_403B70(void *this, char a2)<br>{<br>  char v3[65]; // [esp+Fh] [ebp-45h] BYREF<br>  void *v4; // [esp+50h] [ebp-4h]</p><p>  v4 = this;<br>  v3[0] = a2 ^ 0x14;//进行异或<br>  sub_406170(v3);<br>  return ++dword_4DD8F8;<br>}<br><img src="https://img-blog.csdnimg.cn/fb296bf4343342f5981cd3cf8e203417.png" alt="在这里插入图片描述"></p><p>脚本：<br>s =’rxusoCqxw{yqK<code>&#123;KZqag&#123;r</code>i’<br>for i in range(len(s)):<br>    print (chr(ord(s[i])^0x14),end = ‘’)<br>运行得到flag{Welcome_to_Neusoft}</p><h2 id="9-xxxorrr"><a href="#9-xxxorrr" class="headerlink" title="9.xxxorrr"></a>9.xxxorrr</h2><p>拖入exe<br><img src="https://img-blog.csdnimg.cn/26dbb8640ecd4345b97323599060eeec.png" alt="在这里插入图片描述"></p><p>拖入64位IDA，找到main函数<br><img src="https://img-blog.csdnimg.cn/4f07939d7e5447b492a8df6336254b96.png" alt="在这里插入图片描述"></p><p>双击跟进sub_916<br><img src="https://img-blog.csdnimg.cn/7d2da8e6505b40eeb659a1e151a3e628.png" alt="在这里插入图片描述"></p><p>这里将s1和s2对比，相同就正确，所以s1应该就是flag加密后的字符串<br>unsigned __int64 sub_84A()<br>{<br>  int i; // [rsp+Ch] [rbp-14h]<br>  unsigned __int64 v2; // [rsp+18h] [rbp-8h]</p><p>  v2 = __readfsqword(0x28u);<br>  for ( i = 0; i &lt;= 33; ++i )<br>    s1[i] ^= 2 * i + 65;<br>  return __readfsqword(0x28u) ^ v2;<br>}<br>这是加密s1的函数，看到进行了一次异或<br>函数整体分析，函数先将输入的s与s1进行异或得到新s1，新s1经过sub_84A()函数加密后得到的s1与s2相同<br>解题思路：将s2与s1异或得到s1异或前的元素，通过加密函数逆向推出正确的flag<br>脚本：<br>s2=[ 0x56, 0x4E, 0x57, 0x58, 0x51, 0x51, 0x09, 0x46, 0x17, 0x46,<br>  0x54, 0x5A, 0x59, 0x59, 0x1F, 0x48, 0x32, 0x5B, 0x6B, 0x7C,<br>  0x75, 0x6E, 0x7E, 0x6E, 0x2F, 0x77, 0x4F, 0x7A, 0x71, 0x43,<br>  0x2B, 0x26, 0x89, 0xFE, 0x00]<br>s1 = ‘qasxcytgsasxcvrefghnrfghnjedfgbhn’<br>flag=’’<br>for i in range(33):<br>     flag+=chr(ord(s1[i])^ (2 * i + 65)^s2[i])<br>print(flag)<br>运行得到 flag{c0n5truct0r5_functi0n_in_41f}</p><h2 id="10-bad-python"><a href="#10-bad-python" class="headerlink" title="10.bad_python"></a>10.bad_python</h2><p>(5条消息) 攻防世界Reverse简单难度bad_python题解_pyc 文件头_shenkong_的博客-CSDN博客</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;攻防世界&lt;/p&gt;
&lt;h2 id=&quot;1-Reversing-x64Elf-100&quot;&gt;&lt;a href=&quot;#1-Reversing-x64Elf-100&quot; class=&quot;headerlink&quot; title=&quot;1.Reversing-x64Elf-100&quot;&gt;&lt;/a&gt;1.Revers</summary>
      
    
    
    
    <category term="刷题" scheme="https://hzy2003628.top/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="寒假刷题记录" scheme="https://hzy2003628.top/tags/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>WAF</title>
    <link href="https://hzy2003628.top/2023/02/23/Waf/"/>
    <id>https://hzy2003628.top/2023/02/23/Waf/</id>
    <published>2023-02-23T12:15:28.828Z</published>
    <updated>2023-02-21T13:07:05.987Z</updated>
    
    <content type="html"><![CDATA[<p>Waf<br>WAF具备限制对某些URI请求次数的能力和限制文件上传功能的能力。<br>windows 或 linux 下:<br>command1 &amp;&amp; command2 先执行 command1，如果为真，再执行 command2<br>command1 | command2 只执行 command2<br>command1 &amp; command2 先执行 command2 后执行 command1<br>command1 || command2 先执行 command1，如果为假，再执行 command2<br>命令执行漏洞（| || &amp; &amp;&amp; 称为 管道符）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Waf&lt;br&gt;WAF具备限制对某些URI请求次数的能力和限制文件上传功能的能力。&lt;br&gt;windows 或 linux 下:&lt;br&gt;command1 &amp;amp;&amp;amp; command2 先执行 command1，如果为真，再执行 command2&lt;br&gt;command1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python常用函数语段</title>
    <link href="https://hzy2003628.top/2023/02/23/Python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AF%AD%E6%AE%B5/"/>
    <id>https://hzy2003628.top/2023/02/23/Python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AF%AD%E6%AE%B5/</id>
    <published>2023-02-23T12:15:28.825Z</published>
    <updated>2023-02-21T13:07:39.130Z</updated>
    
    <content type="html"><![CDATA[<p>Python常用函数语段</p><h2 id="一-chr-函数"><a href="#一-chr-函数" class="headerlink" title="一.chr() 函数;"></a>一.chr() 函数;</h2><p>chr() 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。<br>chr(i),i – 可以是10进制也可以是16进制的形式的数字。<br>返回值是当前整数对应的 ASCII 字符。<br>例：print chr(78) 结果显示为N<br>比较：ord函数；<br>Ord(“字符串”)  函数返回值类型为int类型<br>例：ord(“0”) 结果显示48</p><h2 id="二-for-i-in-range-作用"><a href="#二-for-i-in-range-作用" class="headerlink" title="二.for i in range ()作用"></a>二.for i in range ()作用</h2><p>for i in range ()作用：<br>range()是一个函数， for i in range () 就是给i赋值：<br>比如 for i in range （1，3）：<br>就是把1,2依次赋值给i<br>range () 函数的使用是这样的:<br>range(start, stop[, step])，分别是起始、终止和步长<br>range（3）即：从0到3，不包含3，即0,1,2<br>range(1,3) 即：从1到3，不包含3，即1,2<br>range（1,3,2）即：从1到3，每次增加2，因为1+2=3，所以输出只有1<br>第三个数字2是代表步长。如果不设置，就是默认步长为1<br>解题脚本是这样描述的: for i in range(0,18,3): 意思是 0-18不包括18,三个数为一组</p><h2 id="三-split"><a href="#三-split" class="headerlink" title="三.split"></a>三.split</h2><p>split() 方法可以实现将一个字符串按照指定的分隔符切分成多个子串，这些子串会被保存到列表中（不包含分隔符），作为方法的返回值反馈回来。<br>例子:<br>a = “8842101220480224404014224202480122”<br>a = a.split(“0”) 把这一串字符变为:88421, 122 48 2244等</p><h2 id="四-for-i-in-a"><a href="#四-for-i-in-a" class="headerlink" title="四 for i in a:"></a>四 for i in a:</h2><p>for循环遍历语法 把a变量里包含的内容以循环的方式一个一个放到i变量里面;<br>例题</p><pre><code class="hljs python">a=[<span class="hljs-number">118</span>,<span class="hljs-number">104</span>,<span class="hljs-number">102</span>,<span class="hljs-number">120</span>,<span class="hljs-number">117</span>,<span class="hljs-number">108</span>,<span class="hljs-number">119</span>,<span class="hljs-number">124</span>,<span class="hljs-number">48</span>,<span class="hljs-number">123</span>,<span class="hljs-number">101</span>,<span class="hljs-number">120</span>]s=<span class="hljs-string">&#x27; &#x27;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:   s+=<span class="hljs-built_in">chr</span>(i-<span class="hljs-number">3</span>)<span class="hljs-built_in">print</span>(s)</code></pre><p>把a里面的内容一个一个的放入i里面进行运算;</p><h2 id="五-def"><a href="#五-def" class="headerlink" title="五.def"></a>五.def</h2><p>意思是自己定义一个函数;<br><img src="https://img-blog.csdnimg.cn/78bf9b9a4d2f47aeba74d8857e15a74f.png" alt="在这里插入图片描述"></p><p>这一串即是自己定义的加密函数 encode是加密, decode是解密</p><h2 id="六-lower"><a href="#六-lower" class="headerlink" title="六 lower()"></a>六 lower()</h2><p>描述：将字符串中的所有大写字母转换为小写字母。<br>注意 lower()函数和casefold()函数的区别：<br>lower() 方法只对ASCII编码，即‘A-Z’有效，对于其它语言中把大写转换为小写的情况无效，只能用 casefold() 函数。<br>例如:print(t2.lower()) 意思是把t2字符串变为小写字母</p><h2 id="七-进制转换函数"><a href="#七-进制转换函数" class="headerlink" title="七 进制转换函数"></a>七 进制转换函数</h2><p><img src="https://img-blog.csdnimg.cn/3617a6639fae4e17acfdd0a1f27fd53f.png" alt="在这里插入图片描述"></p><p>原理：python内置函数进行进制转换的原理是将读入的一个字符串（python默认读入的都是字符串形式）转为10进制，然后再用相关函数进行其他进制转换<br>chr(int(s, 16)) 意思是从16进制转10; ASC码转换成字母输出</p><h2 id="八-文件的读写"><a href="#八-文件的读写" class="headerlink" title="八 文件的读写"></a>八 文件的读写</h2><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;filename.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:   data_user=pd.read_csv(f)  <span class="hljs-comment">#文件的读操作</span><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:   f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)  <span class="hljs-comment">#文件的写操作</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python常用函数语段&lt;/p&gt;
&lt;h2 id=&quot;一-chr-函数&quot;&gt;&lt;a href=&quot;#一-chr-函数&quot; class=&quot;headerlink&quot; title=&quot;一.chr() 函数;&quot;&gt;&lt;/a&gt;一.chr() 函数;&lt;/h2&gt;&lt;p&gt;chr() 用一个范围在 range（2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ping</title>
    <link href="https://hzy2003628.top/2023/02/23/Ping/"/>
    <id>https://hzy2003628.top/2023/02/23/Ping/</id>
    <published>2023-02-23T12:15:28.823Z</published>
    <updated>2023-02-21T13:08:06.422Z</updated>
    
    <content type="html"><![CDATA[<p>Ping<br>ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。<br>应用格式：Ping空格IP地址。该命令还可以加许多参数使用，具体是键入Ping按回车即可看到详细说明。<br>作用：它是用来检查网络是否通畅或者网络连接速度的命令。<br>ping命令的使用方法：<br>方法/步骤<br>首先用快捷键win+R调出运行命令框，输入cmd，点击确定，会弹出DOS窗口。<br>ping命令的应用格式：<br>①ping+IP地址或主机域名；<br>②ping+IP地址或主机域名+命令参数；<br>③ ping+命令参数+IP地址或主机域名 。注意，“+”要换成空格！当我们使用第①种格式时，默认只发送四个数据包。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Ping&lt;br&gt;ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。&lt;br&gt;应用格式：Ping空格IP地址。该命令还可以加许多</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OllyDbg 常用快捷热键</title>
    <link href="https://hzy2003628.top/2023/02/23/OllyDbg%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E7%83%AD%E9%94%AE/"/>
    <id>https://hzy2003628.top/2023/02/23/OllyDbg%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E7%83%AD%E9%94%AE/</id>
    <published>2023-02-23T12:15:28.820Z</published>
    <updated>2023-02-21T13:08:38.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OllyDbg-常用快捷热键"><a href="#OllyDbg-常用快捷热键" class="headerlink" title="OllyDbg 常用快捷热键"></a>OllyDbg 常用快捷热键</h2><p>打开一个新的可执行程序 (F3)</p><p>重新运行当前调试的程序 (Ctrl+F2)</p><p>当前调试的程序 (Alt+F2)</p><p>运行选定的程序进行调试 (F9)</p><p>暂时停止被调试程序的执行 (F12)</p><p>单步进入被调试程序的 Call 中 (F7)</p><p>步过被调试程序的 Call (F8)</p><p>跟入被调试程序的 Call 中 (Ctrl+F11)</p><p>跟踪时跳过被调试程序的 Call (Ctrl+F12)</p><p>执行直到返回 (Ctrl+F9)</p><p>显示记录窗口 (Alt+L)</p><p>显示模块窗口 (Alt+E)</p><p>显示内存窗口 (Alt+M)</p><p>显示 CPU 窗口 (Alt+C)</p><p>显示补丁窗口 (Ctrl+P)</p><p>显示呼叫堆栈 (Alt+K)</p><p>显示断点窗口 (Alt+B)</p><p>打开调试选项窗口 (Alt+O)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OllyDbg-常用快捷热键&quot;&gt;&lt;a href=&quot;#OllyDbg-常用快捷热键&quot; class=&quot;headerlink&quot; title=&quot;OllyDbg 常用快捷热键&quot;&gt;&lt;/a&gt;OllyDbg 常用快捷热键&lt;/h2&gt;&lt;p&gt;打开一个新的可执行程序 (F3)&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux 系统实现 SSH 连接的 3 种 方式</title>
    <link href="https://hzy2003628.top/2023/02/23/Linux%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0SSH%E8%BF%9E%E6%8E%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://hzy2003628.top/2023/02/23/Linux%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0SSH%E8%BF%9E%E6%8E%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2023-02-23T12:15:28.818Z</published>
    <updated>2023-02-21T13:09:17.498Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 系统实现 SSH 连接的 3 种 方式<br>密码登入<br>公钥登入<br>私钥登入<br>登入前提<br>服务端安装好 ssh 服务, openssh-server<br>客户端与服务器端均要拥有 ssh-key，可以使用命令 ls ~/.ssh/ 来查看是否拥有 id_rsa 与 id_rsa.pub 文件，如果没有同时拥有这两个文件，那就执行命令ssh-keygen并持续按回车键生成它们<br>前提假设 ：客户端 A 远程连接服务端 B，A 的 IP 等于10.10.10.104，B 的 IP 等于172.19.0.2</p><h4 id="方式一：密码登入"><a href="#方式一：密码登入" class="headerlink" title="方式一：密码登入"></a>方式一：密码登入</h4><p>原理：执行远程连接命令并输入账号密码</p><p>客户端 A 连接服务端 B，客户端 A 中执行命令 ssh <a href="mailto:&#x72;&#x6f;&#111;&#x74;&#64;&#x31;&#x37;&#50;&#46;&#x31;&#x39;&#46;&#x30;&#x2e;&#x32;">&#x72;&#x6f;&#111;&#x74;&#64;&#x31;&#x37;&#50;&#46;&#x31;&#x39;&#46;&#x30;&#x2e;&#x32;</a> 去连接 B。命令中的 root 是服务端 B 的用户名<br>接着就是输入密码即可</p><h4 id="方式二：公钥登入（免密登入）"><a href="#方式二：公钥登入（免密登入）" class="headerlink" title="方式二：公钥登入（免密登入）"></a>方式二：公钥登入（免密登入）</h4><p>原理：注入公钥到服务端，表示拥有该公钥的客户端可以免密登入</p><p>将客户端 A 的公钥<del>/.ssh/id_rsa.pub复制到服务端 B 的授权Key文件</del>/.ssh/authorized_keys中。可采用手动方式，也可以在客户端 A 执行命令 ssh-copy-id <a href="mailto:&#x72;&#111;&#x6f;&#116;&#64;&#x31;&#55;&#50;&#x2e;&#49;&#x39;&#x2e;&#48;&#x2e;&#50;">&#x72;&#111;&#x6f;&#116;&#64;&#x31;&#55;&#50;&#x2e;&#49;&#x39;&#x2e;&#48;&#x2e;&#50;</a>来实现<br>在客户端 A 执行命令 ssh 172.19.0.2 即可实现免密登入</p><h4 id="方式三：秘钥文件登入"><a href="#方式三：秘钥文件登入" class="headerlink" title="方式三：秘钥文件登入"></a>方式三：秘钥文件登入</h4><p>原理：客户端每次登入时携带服务端秘钥来登入</p><p>将服务端 B 的私钥<del>/.ssh/id_rsa复制到客户端 A 中，假设放在</del>/.ssh/b_id_rsa，并修改权限为只读。在客户端 A 中执行命令chmod 400 ~/.ssh/b_id_rsa来修改权限<br>在客户端 A 执行命令 ssh -i ~/.ssh/b_id_rsa <a href="mailto:&#114;&#x6f;&#x6f;&#116;&#x40;&#x31;&#x37;&#50;&#46;&#x31;&#x39;&#46;&#48;&#x2e;&#x32;">&#114;&#x6f;&#x6f;&#116;&#x40;&#x31;&#x37;&#50;&#46;&#x31;&#x39;&#46;&#48;&#x2e;&#x32;</a> 即可实现登入<br>提示：<br>如果服务端 B 的 ssh 服务所监听的端口不是 22 ，假如是 33，那么在客户端 A 连接时，需要加上 -p 33 来连接。比如：ssh -p 33 <a href="mailto:&#114;&#x6f;&#x6f;&#x74;&#64;&#49;&#55;&#50;&#46;&#49;&#x39;&#x2e;&#x30;&#46;&#x32;">&#114;&#x6f;&#x6f;&#x74;&#64;&#49;&#55;&#50;&#46;&#49;&#x39;&#x2e;&#x30;&#46;&#x32;</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux 系统实现 SSH 连接的 3 种 方式&lt;br&gt;密码登入&lt;br&gt;公钥登入&lt;br&gt;私钥登入&lt;br&gt;登入前提&lt;br&gt;服务端安装好 ssh 服务, openssh-server&lt;br&gt;客户端与服务器端均要拥有 ssh-key，可以使用命令 ls ~/.ssh/ 来查看是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IDA快捷键</title>
    <link href="https://hzy2003628.top/2023/02/23/IDA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://hzy2003628.top/2023/02/23/IDA%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2023-02-23T12:15:28.815Z</published>
    <updated>2023-02-21T13:09:57.062Z</updated>
    
    <content type="html"><![CDATA[<p>IDA快捷键<br>F5+空格     chr  ord<br>upx脱壳<br>v5+i=v5[i]</p><p>ida小端序<br> r转换成字符  倒着读  h切换为10进制<br> shift+f12快捷命令进入<br>a：将数据转换为字符串<br>esc：回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口）<br>shift+f12：可以打开string窗口，一键找出所有的字符串，右击setup，还能对窗口的属性进行设置<br>ctrl+w：保存ida数据库<br>ctrl+s：选择某个数据段，直接进行跳转<br>ctrl+鼠标滚轮：能够调节流程视图的大小<br>x：对着某个函数、变量按该快捷键，可以查看它的交叉引用<br>g：直接跳转到某个地址<br>n：更改变量的名称<br>y：更改变量的类型<br>/ ：在反编译后伪代码的界面中写下注释<br>\：在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多<br>；：在反汇编后的界面中写下注释<br>ctrl+shift+w：拍摄IDA快照<br>u：undefine，取消定义函数、代码、数据的定义<br>D（Data）：即让某一个位置变成数据。一直以按D键，这个位置的数据类型将会以1字节，2字节，4字节，8字节进行循环。IDA为了防止误操作，如果定义数据的操作会影响到已经有数据类型的位置，IDA会弹出确认的对话框；如果操作的位置及其附近完全十Undefined，则不会弹出确认对话框。<br>C（Code）键：即让某一个位置变为指令。确认对话框的弹出时机也与D键类似。在定义为指令后，IDA会自动以此为其实位置进行递归下降反汇编<br>A（ASCII）键：会以该位置为起点定义一个“\0”结尾的字符串类型。<br>*键：将此处定义为一个数组，此时弹出一个对话框，用来设置数组的属性。<br>O(Offset）键：即将此处定义为一个地址偏移.</p><p>下面的是函数的操作<br>删除函数：在函数窗口中选中函数，按Delete键；<br>定义函数：在反汇编窗口中选中对应行后，按P键；<br>修改函数参数：在函数窗口中选中并按Ctrl+E组合键，或在反汇编窗口的函数内部按Alt+P组合键。</p><p>下面是导航操作<br>后退到上一步位置：快捷键Esc<br>前进到下一个位置：快捷键Ctrl+Enter。<br>跳转到某一个特定位置：快捷键G，然后可以输入地址/已经定义的名称。<br>跳转到某一区段：快捷键Ctrl+S，然后选择区段即可。<br>Shift+e 数据总结</p><p>OD 右键-&gt;中文搜索引擎-&gt;ASCII码  F2下端点-&gt;运行  cmp比较  nop空命令   jmp跳转</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IDA快捷键&lt;br&gt;F5+空格     chr  ord&lt;br&gt;upx脱壳&lt;br&gt;v5+i=v5[i]&lt;/p&gt;
&lt;p&gt;ida小端序&lt;br&gt; r转换成字符  倒着读  h切换为10进制&lt;br&gt; shift+f12快捷命令进入&lt;br&gt;a：将数据转换为字符串&lt;br&gt;esc：回退键</summary>
      
    
    
    
    
  </entry>
  
</feed>
